-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm ) -- для менеджера сигналов
  sm:subscribe({ signal = "on_mm_return_game", fun = this.on_mm_return_game })
  sm:subscribe({ signal = "on_spawn",          fun = this.on_spawn })
end


-- читаем глобальные параметры эффектов здоровья
local satiety_v = get_float( "actor_script_condition", "satiety_v" )
ASSERT(
  satiety_v, "[%s]: 'satiety_v' not found", script_name()
)

local light_hunger_limit = get_float(
  "actor_script_condition", "light_hunger_limit"
)
ASSERT(
  light_hunger_limit, "[%s]: 'light_hunger_limit' not found", script_name()
)

local critical_hunger_limit = get_float(
  "actor_script_condition", "critical_hunger_limit"
)
ASSERT(
  critical_hunger_limit,
  "[%s]: 'critical_hunger_limit' not found", script_name()
)

local satiety_power_factor = get_float(
  "actor_script_condition", "satiety_power_factor"
)
ASSERT(
  satiety_power_factor,
  "[%s]: 'satiety_power_factor' not found", script_name()
)

local satiety_health_factor = get_float(
  "actor_script_condition", "satiety_health_factor"
)
ASSERT(
  satiety_health_factor,
  "[%s]: 'satiety_health_factor' not found", script_name()
)
local def_stand_power = get_float( "actor_condition", "stand_power" )
local cur_stand_power = def_stand_power
local satiety_k       = def_stand_power
  * ( 1 - satiety_power_factor ) / light_hunger_limit

local satiety_health_v    = get_float( "actor_condition", "satiety_health_v" )
local satiety_power_v     = get_float( "actor_condition", "satiety_power_v"  )
local wound_incarnation_v = get_float(
  "actor_condition", "wound_incarnation_v"
)

local sprint_koef = get_float( "actor", "sprint_koef" )
local cur_sprint_koef, override_sprint_koef

local walk_accel     = get_float( "actor", "walk_accel" )
local min_walk_accel = 6
local override_walk_accel

local def_jump_power = get_float( "actor_condition", "jump_power" )
local cur_jump_power, override_jump_power

local overweight_jump_k = get_float( "actor_condition", "overweight_jump_k" )
local overweight_walk_k = get_float( "actor_condition", "overweight_walk_k" )

local jump_speed = get_float( "actor", "jump_speed" )
local override_jump_speed


local cur_cam_inert, new_cam_inert
local health_t, satiety_t
local pt

function on_spawn()
  if db.actor.health < 0.9 then
    health_t = 0
  end
  if db.actor.satiety < light_hunger_limit then
    satiety_t = 0
  end
  dsh.exec_on_update(
    function()
      pt = game.CTime( game.get_game_time() )
    end
  )
  local sm = ogse_signals.get_mgr()
  sm:subscribe({
    signal = "on_update", fun = this.on_update,
    [ "script_name" ] = ( script_name() .. ".on_update" )
  })
  sm:subscribe({
    signal = "on_update", fun = this.apply_weight,
    [ "script_name" ] = ( script_name() .. ".apply_weight" )
  })
  sm:subscribe({
    signal = "on_update", fun = this.apply_conds,
    [ "script_name" ] = ( script_name() .. ".apply_conds" )
  })
end


local cached_item_cond_effects = {}

local function get_item_cond_effect( item )
  local section = item:section()
  local ef      = cached_item_cond_effects[ section ]
  if not ef then
    ef = {}
    ef.satiety_restore_speed  = get_float( section, "satiety_restore_speed",  0 )
    ef.health_restore_speed   = get_float( section, "health_restore_speed",   0 )
    ef.bleeding_restore_speed = get_float( section, "bleeding_restore_speed", 0 )
    ef.power_restore_speed    = get_float( section, "power_restore_speed",    0 )
    ef.additional_inventory_weight  = get_float(
      section, "additional_inventory_weight",  0
    )
    ef.additional_inventory_weight2 = get_float(
      section, "additional_inventory_weight2", 0
    )
    cached_item_cond_effects[ section ] = ef
  end
  return ef
end


has_overweight = false
local cur_walk_accel = walk_accel - min_walk_accel
local ext            = {
  [ "alcohol_restore_speed"    ] = 0,
  [ "bleeding_restore_speed"   ] = 0,
  [ "health_restore_speed"     ] = 0,
  [ "power_restore_speed"      ] = 0,
  [ "psy_health_restore_speed" ] = 0,
  [ "radiation_restore_speed"  ] = 0,
  [ "satiety_restore_speed"    ] = 0,
  [ "sprint_koef_add"          ] = 0,
  [ "walk_accel_add"           ] = 0,
}
local override_power = 1
local use_overweight = true
local overweight_k   = 0

function on_update()
  local dt = game.get_game_time():diffSec( pt )
  pt = game.CTime( game.get_game_time() )
  if dt == 0 then return end
  if not db.actor:alive() then return end
  for k, v in pairs( ext ) do
    ext[ k ] = 0
  end
  ogse_signals.get_mgr():call( "on_before_actor_conditions_update", ext )

  local act = db.actor
  -- учитываем здесь естественное оголодание, а также движковое (
  -- обнулять его нельзя, на нем основан показ свойств артефактов )
  local cur_satiety_v = satiety_v
    * ( 1 - math.min( act.health, override_power ) )
  if act:is_actor_sprinting() or act:is_actor_climbing() then
    cur_satiety_v = cur_satiety_v + satiety_v
  end
  if act.health < 1 then
    local belt_health_restore_speed = inventory.on_belt_restore_speed(
      "health_restore_speed"
    )
    if belt_health_restore_speed > 0 then
      cur_satiety_v = cur_satiety_v
        + satiety_v * ( belt_health_restore_speed / satiety_health_v )
    end
  end
  if act:get_bleeding() > 0 then
    local belt_bleeding_restore_speed = inventory.on_belt_restore_speed(
      "bleeding_restore_speed"
    )
    if belt_bleeding_restore_speed > 0 then
      cur_satiety_v = cur_satiety_v
        + satiety_v * ( belt_bleeding_restore_speed / wound_incarnation_v )
    end
  end
  local cur_power_restore_speed = inventory.on_belt_restore_speed(
    "power_restore_speed"
  ) + ext.power_restore_speed
  if cur_power_restore_speed > 0 then
    cur_satiety_v = cur_satiety_v
      + satiety_v * ( cur_power_restore_speed / satiety_power_v / 100 )
  end
  local summary_satiety_effect = cur_satiety_v
    + inventory.on_belt_restore_speed( "satiety_restore_speed" )
    + ext.satiety_restore_speed
  local summary_health_effect            = ext.health_restore_speed
  local summary_power_effect             = ext.power_restore_speed
  local summary_bleeding_restore_effect  = ext.bleeding_restore_speed
  local summary_psy_health_effect        = ext.psy_health_restore_speed
  local summary_radiation_restore_effect = ext.radiation_restore_speed
  local summary_alcohol_effect           = ext.alcohol_restore_speed
  -- эффекты от брони
  local armor = db.actor:get_current_outfit()
  if armor then
    local armor_ef = get_item_cond_effect( armor )
    summary_satiety_effect = summary_satiety_effect + armor_ef.satiety_restore_speed
    summary_health_effect  = summary_health_effect  + armor_ef.health_restore_speed
    summary_power_effect   = summary_power_effect   + armor_ef.power_restore_speed
    summary_bleeding_restore_effect = summary_bleeding_restore_effect
      + armor_ef.bleeding_restore_speed
  end

  -- эффекты, связанные c голодом
  if act.satiety < light_hunger_limit then
    local sadd = ( light_hunger_limit - act.satiety ) * satiety_k
    cur_stand_power = def_stand_power + sadd
  else
    cur_stand_power = def_stand_power
  end

  if act.satiety < critical_hunger_limit then
    local hadd = ( act.satiety - critical_hunger_limit )
      * satiety_health_factor
    summary_health_effect = summary_health_effect + hadd
  end

  -- TODO: учесть потерю сил и здоровья от недосыпа
  --
  --TODO: оптимизировать вычисление суммарного эффекта,
  -- сделать это только по факту изменения объектов на поясе
  act.satiety = summary_satiety_effect * dt
  -- ограничиваем снизу. TODO: может учесть это в самом движке
  if act.satiety < 0 then act:set_actor_condition_float( nil, 0.0, 256 ) end
  act.health = summary_health_effect * dt
  if not ogse_sleep_mgr.is_sleep_active() then
    act.power = summary_power_effect * dt
  end
  if math.abs( summary_bleeding_restore_effect ) > 0 then
    if act:get_bleeding() > 0 then
      act:heal_wounds( summary_bleeding_restore_effect * dt )
    end
  end
  act.radiation = summary_radiation_restore_effect * dt
  if math.abs( summary_psy_health_effect ) > 0 then
    act.psy_health = summary_psy_health_effect * dt
  end
  if math.abs( summary_alcohol_effect ) > 0 then
    act.alcohol = summary_alcohol_effect * dt
  end

  cur_sprint_koef = override_sprint_koef or (
    sprint_koef + ext.sprint_koef_add
  )

  cur_walk_accel = walk_accel - min_walk_accel
  if act.satiety < light_hunger_limit then
    if not satiety_t then satiety_t = time_global() + 30000 end
    if satiety_t < time_global() then
      cur_walk_accel = cur_walk_accel * ( act.satiety / light_hunger_limit )
    end
  else
    satiety_t = nil
  end
  if act.health < 0.9 then
    if not health_t then health_t = time_global() + 30000 end
    if health_t < time_global() then
      cur_walk_accel = cur_walk_accel * ( act.health / 0.9 )
    end
  else
    health_t = nil
  end

  if has_overweight and use_overweight then
    local k2       = 1 - overweight_k
    cur_walk_accel = cur_walk_accel * k2
    new_cam_inert  = overweight_k
    if k2 < 0.1 then
      override_power = 0.1
    else
      override_power = k2
    end
  else
    override_power = 1
    new_cam_inert  = 0
  end

  if act.power < 0.3 then
    cur_walk_accel = cur_walk_accel * ( act.power / 0.3 )
    local power_inert = 1 - act.power / 0.3
    if power_inert > new_cam_inert then new_cam_inert = power_inert end
  end
  cur_walk_accel = cur_walk_accel + ext.walk_accel_add

  cur_jump_power = override_jump_power or def_jump_power
  if act.satiety < light_hunger_limit and satiety_t < time_global() then
    cur_jump_power = cur_jump_power + (
      ( 0.4 - cur_jump_power ) * ( 1 - ( act.satiety / light_hunger_limit ) )
    )
  end
  if act.health < 0.9 and health_t < time_global() then
    cur_jump_power = cur_jump_power + (
      ( 0.4 - cur_jump_power ) * ( 1 - ( act.health / 0.9 ) )
    )
    if act.health < 0.8 then
      local health_inert = 0.8 - act.health
      if health_inert > new_cam_inert then new_cam_inert = health_inert end
    end
  end
end


function disable_sprint()
  set_sprint( 1 )
end
function set_sprint( koef )
  override_sprint_koef = koef
end
function restore_sprint()
  set_sprint( nil )
end


function change_jump_power( k )
  override_jump_power = k
end


function change_jump_speed( k )
  override_jump_speed = k
  set_jump_speed( override_jump_speed or jump_speed )
end


function change_walk_accel( k )
  override_walk_accel = k
  set_walk_accel( override_walk_accel or ( min_walk_accel + cur_walk_accel ) )
end


function get_overweight_power()
  return override_power
end


function switch_use_overweight( mode )
  use_overweight = mode and true or false
end


function apply_weight()
  ogse_signals.get_mgr():reschedule( 1000 )
  local armor = db.actor:get_current_outfit()
  local armor_ef
  if armor then
    armor_ef = get_item_cond_effect( armor )
  end
  local inv_weight = db.actor:get_inventory_weight()
  local max_weight = db.actor:get_actor_max_weight()
    + ( armor_ef and armor_ef.additional_inventory_weight2 or 0 )
  if inv_weight > max_weight and use_overweight then
    has_overweight    = true
    local walk_weight = db.actor:get_actor_max_walk_weight()
      + ( armor_ef and armor_ef.additional_inventory_weight or 0 )
    if inv_weight > walk_weight then inv_weight = walk_weight end
    overweight_k = ( inv_weight - max_weight ) / ( walk_weight - max_weight )
    set_overweight_jump_k( overweight_jump_k )
    set_overweight_walk_k( overweight_walk_k )
  else
    has_overweight = false
    overweight_k   = 0
    set_overweight_jump_k( 1 )
    set_overweight_walk_k( 1 )
  end
end


function apply_conds()
  ogse_signals.get_mgr():reschedule( 1000 )
  set_sprint_factor( cur_sprint_koef )
  set_walk_accel(
    override_walk_accel or ( min_walk_accel + cur_walk_accel )
  )
  if cur_walk_accel < 1 then
    set_jump_speed( 0 )
  else
    set_jump_speed( override_jump_speed or jump_speed )
  end
  set_jump_power( cur_jump_power )
  set_stand_power( cur_stand_power )
  if new_cam_inert ~= cur_cam_inert then
    local cam_inert = dsh_cfg.get_data().cam_inert
    if new_cam_inert > 0 then
      local min_cam_inert = math.max( 0.3, cam_inert + 0.1 )
      if min_cam_inert < 0.8 then
        cmd(
          "cam_inert",
          min_cam_inert + (
            math.round( ( 0.8 - min_cam_inert ) * new_cam_inert * 100 ) / 100
          )
        )
      end
    else
      cmd( "cam_inert", cam_inert )
    end
    cur_cam_inert = new_cam_inert
  end
end


function on_mm_return_game()
  cur_cam_inert = 0
end


function get_satiety_v()
  return satiety_v
end
