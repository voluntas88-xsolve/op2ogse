-- -*- mode: lua; coding: windows-1251-dos -*-

-- Этот скрипт эмулирует поглощение энергии хита артефактами,
-- размещенными на поясе.  Каждый артефакт, находящийся под контролем
-- скрипта, способен поглотить определенное кол-во энергии, после
-- чего, он преобразуется в булыжник.

local our_hits = {              -- какие типы хита будут обрабатываться
  [ hit.explosion ] = {
    [ "max"     ] = 10,           -- порог поглощения
    [ "new_hit" ] = { "bleeding", "health" },
    [ "sect"    ] = "explosion_immunity",
  },
  [ hit.fire_wound ] = {
    [ "max"     ] = 10,
    [ "new_hit" ] = { "bleeding", "health" },
    [ "sect"    ] = "fire_wound_immunity",
    [ "ignored_outfit_protection" ] = false,
  },
  [ hit.strike ] = {
    [ "max"     ] = 10,
    [ "new_hit" ] = { "bleeding", "health" },
    [ "sect"    ] = "strike_immunity",
  },
  [ hit.wound ] = {
    [ "max"     ] = 10,
    [ "new_hit" ] = { "bleeding", "health" },
    [ "sect"    ] = "wound_immunity",
  },
  [ hit.burn ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "burn_immunity",
  },
  [ hit.chemical_burn ] = {
    [ "max"     ] = 10,
    [ "new_hit" ] = { "bleeding" },
    [ "sect"    ] = "chemical_burn_immunity",
  },
  [ hit.shock ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "shock_immunity",
  },
  [ hit.radiation ] = {
    [ "max"     ] = 100,
    [ "new_hit" ] = { "radiation" },
    [ "sect"    ] = "radiation_immunity",
  },
  [ hit.telepatic ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "telepatic_immunity",
  },
  [ "bleeding" ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "bleeding_restore_speed",
  },
  [ "health" ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "health_restore_speed",
  },
  [ "power" ] = {
    [ "max"  ] = 250,
    [ "sect" ] = "power_restore_speed",
  },
  [ "radiation" ] = {
    [ "max"  ] = 250,
    [ "sect" ] = "radiation_restore_speed",
  },
  [ "satiety" ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "satiety_restore_speed",
  },
  [ "weight2" ] = {
    [ "max"  ] = 950400, -- 24 часа для Булыжника (11 кг.)
    [ "sect" ] = "additional_inventory_weight2",
  },
}


function attach( sm )
  sm:subscribe({ signal = "on_actor_before_hit", fun = this.before_hit })
  sm:subscribe({ signal = "on_first_update",     fun = this.on_first_update })
  sm:subscribe({ signal = "on_use",              fun = this.on_use  })
end


local pt
function on_first_update()
  pt = game.CTime( game.get_game_time() )
  local sm = ogse_signals.get_mgr()
  sm:subscribe({
    signal = "on_update", fun = this.process_hits,
    [ "script_name" ] = ( script_name() .. ".process_hits" )
  })
  sm:subscribe({
    signal = "on_update", fun = this.process_arts,
    [ "script_name" ] = ( script_name() .. ".process_arts" )
  })
end


local got_hits = {}
local has_hit  = false
local new_hit  = {
  [ "bleeding"  ] = false,
  [ "health"    ] = false,
  [ "radiation" ] = false,
}
local psy_block_t

function before_hit( hit_data, p_s_hit, p_ignore_flags )
  local hit_type = hit_data.hit_type
  local our_hit  = our_hits[ hit_type ]
  local power    = hit_data.power
  if our_hit and power > 0 then
    local real_power = calc_real_hit_power( our_hit, hit_data )
    if real_power > 0 then
      got_hits[ hit_type ] = ( got_hits[ hit_type ] or 0 ) + real_power
      has_hit = true
      if our_hit.new_hit then
        for _, k in ipairs( our_hit.new_hit ) do
          new_hit[ k ] = true
        end
      end
    end
    if our_hit.ignored_outfit_protection then
      apply_outfit_protection( hit_data, p_s_hit )
    end
    if hit_data.hit_type == hit.telepatic
      and psy_block_t and time_global() < psy_block_t
    then
      power = 0
      write_memory_float( power, p_s_hit, hit_offset.power )
    end
  end
end


function apply_outfit_protection( hit_data, p_s_hit )
  if db.actor and db.actor:alive() then
    local outfit_item = db.actor:item_in_slot( 6 )
    if outfit_item then
      local koef    = hit_data.power / 5
      if     koef < 0.1 then
        koef = 0.1
      elseif koef > 1 then
        koef = 1
      end
      local imm_val = db.actor:get_current_outfit_protection(
        hit_data.hit_type
      ) * koef
      if imm_val > 0 then
        write_memory_float(
          hit_data.power * ( 1 - imm_val ),
          p_s_hit,
          hit_offset.power
        )
      end
    end
  end
end


function calc_real_hit_power( our_hit, hit_data )
  local hit_power = hit_data.power
  -- вычислить хит до его поглощения артефактами
  local hit_immunity = inventory.on_belt_hit_immunity( our_hit.sect )
  if hit_immunity > 0 then
    hit_power = hit_power / ( 1 - hit_immunity )
  end
  return hit_power
end


local absorbations   = {}
local need_addl_keys = {
  [ "additional_inventory_weight2" ] =  1,
  [ "bleeding_restore_speed"       ] =  1,
  [ "health_restore_speed"         ] =  1,
  [ "power_restore_speed"          ] =  1,
  [ "radiation_restore_speed"      ] = -1,
  [ "satiety_restore_speed"        ] =  1,
}
function get_absorbations( af )
  local af_sect = af:section()
  if not absorbations[ af_sect ] then
    local absorb_sect = get_string( af_sect, "hit_absorbation_sect" )
    if absorb_sect then
      if not absorbations[ af_sect ] then
        absorbations[ af_sect ] = {}
        for _, k in ipairs( get_section_keys( absorb_sect ) ) do
          local absorb_val = 1 - get_float( absorb_sect, k, 1 )
          if absorb_val > 0 then
            absorbations[ af_sect ][ k ] = absorb_val
          end
        end
      end
    end
    for k, v in pairs( need_addl_keys ) do
      local val = get_float( af_sect, k, 0 )
      if     v > 0 and val > 0 then
        absorbations[ af_sect ][ k ] = val
      elseif v < 0 and val < 0 then
        absorbations[ af_sect ][ k ] = math.abs( val )
      end
    end
  end
  return absorbations[ af_sect ]
end


function process_hits()
  local dt = game.get_game_time():diffSec( pt )
  pt = game.CTime( game.get_game_time() )

  got_hits.satiety = ( got_hits.satiety or 0 ) + dt
  got_hits.weight2 = ( got_hits.weight2 or 0 ) + dt

  local act = db.actor
  if act:get_bleeding() > 0 or new_hit.bleeding then
    got_hits.bleeding = ( got_hits.bleeding or 0 ) + dt
    new_hit.bleeding  = false
    has_hit = true
  end

  if act.health < 1 or new_hit.health then
    got_hits.health = ( got_hits.health or 0 ) + dt
    new_hit.health  = false
    has_hit = true
  end

  if
    act.power < 0.99
    or act:is_actor_running()
    or act:is_actor_sprinting()
    or act:is_actor_climbing()
  then
    got_hits.power = ( got_hits.power or 0 ) + dt
    has_hit = true
  end

  if
    act.radiation > 0
    or new_hit.radiation
    or arc_radiation.get_inv_arts_radiation() > 0
  then
    got_hits.radiation = ( got_hits.radiation or 0 ) + dt
    new_hit.radiation  = false
    has_hit = true
  end
end


function process_arts()
  ogse_signals.get_mgr():reschedule( 1000 )
  if
    not (
      has_hit
      or inventory.on_belt_restore_speed_pos( "satiety_restore_speed" )
      or inventory.on_belt_restore_speed_pos( "additional_inventory_weight2" )
    )
  then
    return
  end
  local empty       = {}
  local master_coef = 4 - level.get_game_difficulty()
  for i = 0, db.actor:belt_count() - 1 do
    local af = db.actor:item_on_belt( i )
    if af:is_artefact() then
      local af_sect = af:section()
      local absorbs = get_absorbations( af )
      local af_cond = af:condition()
      if absorbs and af_cond > 0 then
        local cond_diff = 0
        for hit_type, hit_power in pairs( got_hits ) do
          local our_hit = our_hits[ hit_type ]
          if absorbs[ our_hit.sect ] then
            local absorb_val = absorbs[ our_hit.sect ] * hit_power
            cond_diff = cond_diff + (
              absorb_val / ( our_hit.max * master_coef )
            )
          end
        end
        if cond_diff > 0 then
          if af_cond > cond_diff then
            set_condition_on_update( af, af_cond - cond_diff )
          else
            table.insert( empty, af )
          end
        end
      end
    end
  end
  for _, af in ipairs( empty ) do
    --degrade_artefact( af )
  end
  for hit_type, hit_power in pairs( got_hits ) do
    got_hits[ hit_type ] = 0
  end
  has_hit = false
end


function on_use( obj, sobj )
  if obj:section() == "vodka" then
    if psy_block_t and time_global() < psy_block_t then
      psy_block_t = psy_block_t   + 60000
    else
      psy_block_t = time_global() + 60000
    end
    dsh_sleep.change_gg_need_sleep( 30 )
  end
end


function degrade_artefact( af )
  zero_all_af_effects( af )
  dsh.set_condition( af, 0 )
  inventory.rescan_belt()
end


function set_condition_on_update( obj, cond )
  obj:set_condition( cond )
  local tm = dsh.exec_on_update(
    function( id, name )
      local obj = level.object_by_id( id )
      if obj and obj:name() == name then
        dsh.set_condition( obj, cond )
      end
    end,
    obj:id(), obj:name()
  )
  tm.slot_desc.script_name = script_name() .. ".set_condition_on_update"
end
