-- -*- mode: lua; coding: windows-1251-dos -*-
-- nv080209 - adjustments per Russian forum discussion

function attach(sm)
  sm:subscribe({ signal = "on_spawn", fun = this.init })
end


ammo = {}
local inited = false
local repack = false

-- инициализация переменных, выполняется единожды
function init()
  -- список патронов возьмём из "death_generic.ltx"
  for i = 0, sys_ini:line_count( "death_generic.ammo_sections" ) - 1 do
    local result, section, value = sys_ini:r_line(
      "death_generic.ammo_sections", i, "", ""
    )
    ammo[ section ] = {}
    ammo[ section ].repack = false
    ammo[ section ].box    = sys_ini:r_u32( section, "box_size" )
  end
  repack = false
  inited = true
end


-- вызывается при добавлении в инвентарь ГГ любых патрон
--  obj - game_object добавляемой пачки
-- здесь будем только ставить флажки о необходимости проверки,
-- саму проверку и перепаковку сделаем в апдейте актёра,
-- если перепаковку делать прям здесь, то будет глюк при загрузки и
-- при взятии из нычки кучи патрон (взять всё)
function on_take( obj )
  local sobj = alife():object( obj:id() )
  if not sobj then
    log1( "##WARNING! Actor pickup buggy ammopack, removing it." )
    db.actor:drop_item( obj )
    return repack
  end
  local section = obj:section()
  -- nv080209, 080426 prevent CTD if ammo section missing
  if ammo[ section ] then
    if not ammo[ section ].repack then
      if get_ammo_size( obj ) < ammo[ section ].box then
        ammo[ section ].repack = true
        repack = true
      end
    end
  end
  return repack
end


-- вызывается из апдейта актёра
-- проверяет наличие флажков и вызывает процедуру переупаковки
local updates_count =  0
local engage_after  = 20

function on_update()
  if updates_count < engage_after then
    updates_count = updates_count + 1
    return
  end
  if level.main_input_receiver() then return end
  if repack then
    for section, data in pairs( ammo ) do
      if data.repack then
        repack_ammo( section, data.box )
        data.repack = false
      end
    end
    repack = false
  end
end


-- переупаковка патронов заданного типа
--  section - строка, имя секции (тип патрон)
--  box_size - колличество патрон в полной пачке
-- сначало составляем список неполных пачек, затем
-- удаляем их и создаём нужное колличество полных
function repack_ammo( section, box_size )
  local s, t = enum_ammo( section, box_size )
  if s > 0 and table.getn( t ) > 1 then
    for _, id in ipairs( t ) do
      local s_obj = alife():object( id )
      if s_obj then
        alife():release( s_obj )
      end
    end
    local pos  = db.actor:position()
    local lvid = db.actor:level_vertex_id()
    local gvid = db.actor:game_vertex_id()
    local pid  = db.actor:id()
    while s >= box_size do
      alife():create_ammo( section, pos, lvid, gvid, pid, box_size )
      s = s - box_size
    end
    if s > 0 then
      alife():create_ammo( section, pos, lvid, gvid, pid, s )
    end
  end
end


-- пробегаемся по инветарю ГГ и собираем инфу о неполных пачках
--  section - строка, имя секции (тип патрон)
--  box_size - колличество патрон в полной пачке
-- возвращает сумарное колличество патрон в неполных пачках и массив id-шников этих пачек
function enum_ammo( section, box_size )
  local s = 0
  local t = {}
  db.actor:iterate_inventory(
    function( npc, obj )
      if obj:section() == section then
        local size = get_ammo_size( obj )
        if size ~= box_size then
          table.insert( t, obj:id() )
          s = s + size
        end
      end
    end,
    db.actor
  )
  return s, t
end


-- возвращает колличество патрон в пачке
-- http://www.amk-team.ru/forum/index.php?showtopic=10538&p=713968
function get_ammo_size( obj )
  ASSERT( obj, "[dunin_ammo.get_ammo_size] object is a nil reference!" )
  ASSERT(
    obj:is_ammo(),
    "[dunin_ammo.get_ammo_size] object '%s' is not an ammo!", obj:name()
  )
  return obj:get_go_int16( "", 476 )
end
