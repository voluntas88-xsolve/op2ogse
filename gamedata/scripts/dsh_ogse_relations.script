-- -*- mode: lua; coding: windows-1251-dos -*-
-------------------------------------------------------------------------------
--| ogse_relations.script                                                   |--
--| Скриптовая обвязка для очистки отношений                                |--
--| K.D., OGS Evolution Team, 2015                                          |--
--| Ревизия: 14/03/2015                                                     |--
-------------------------------------------------------------------------------

function attach(sm)
  sm:subscribe({ signal = "on_goodwill_change", fun = this.on_goodwill_change })
  sm:subscribe({ signal = "on_load",            fun = this.load               })
  sm:subscribe({ signal = "on_npc_before_hit",  fun = this.on_npc_before_hit  })
  sm:subscribe({ signal = "on_npc_death",       fun = this.on_npc_death       })
  sm:subscribe({ signal = "on_npc_spawn",       fun = this.on_npc_spawn       })
  sm:subscribe({ signal = "on_release_npc",     fun = this.on_release         })
  sm:subscribe({ signal = "on_save",            fun = this.save               })
  sm:subscribe({ signal = "on_spawn",           fun = this.on_spawn           })
end


local attitude_neutal_threshold = get_float(
  "game_relations", "attitude_neutal_threshold"
)

local relation_from_to = {}
local relation_to_from = {}

function on_goodwill_change( from, to )
  if from == 0 then return end
  if not relation_from_to[ from ] then relation_from_to[ from ] = {} end
  local goodwill = relation_registry.get_goodwill( from, to )
  if relation_from_to[ from ][ to ] then
    -- log2(
    --   "[%s]: repeated goodwill change %s -> %s: %s",
    --   script_name(), alife():object( from ):name(), alife():object( to ):name(),
    --   goodwill
    -- )
  else
    if ( to == 0 and goodwill < attitude_neutal_threshold ) or to > 0 then
      relation_from_to[ from ][ to ] = true
    end
    if to > 0 then
      if not relation_to_from[ to ] then
        relation_to_from[ to ] = {}
      end
      relation_to_from[ to ][ from ] = true
    end
    -- log2(
    --   "[%s]: goodwill changed %s -> %s: %s",
    --   script_name(), alife():object( from ):name(), alife():object( to ):name(),
    --   goodwill
    -- )
  end
end


function on_release( npc_id )
  if not db.actor then return end
  if npc_id == 0 then return end
  -- log2( "[%s]: %s released", script_name(), npc_id )
  if relation_from_to[ npc_id ] then
    for to, _ in pairs( relation_from_to[ npc_id ] ) do
      if to > 0 then
        relation_to_from[ to ][ npc_id ] = nil
      end
    end
    relation_from_to[ npc_id ] = nil
  end
  if relation_to_from[ npc_id ] then
    for from, _ in pairs( relation_to_from[ npc_id ] ) do
      db.actor:clear_personal_record( from, npc_id )
      relation_from_to[ from ][ npc_id ] = nil
      -- local sobj = alife():object( from )
      -- if sobj then
      --   log2(
      --     "[%s]: relation record cleared for %s", script_name(), sobj:name()
      --   )
      -- else
      --   log2( "[%s]: relation record cleared for %s", script_name(), from )
      -- end
    end
    relation_to_from[ npc_id ] = nil
  end
end


function save()
  local registry, cnt = {}, 0
  for from, _ in pairs( relation_from_to ) do
    local items = {}
    for to, _ in pairs( relation_from_to[ from ] ) do
      table.insert( items, to )
    end
    if table.getn( items ) > 0 then
      table.insert( registry, { from, items } )
      cnt = cnt + table.getn( items )
    end
  end
  log2(
    "[%s]: relation table size is %s: %s items",
    script_name(), table.getn( registry ), cnt
  )
  ogse.save_var(
    "dsh_ogse_relations.relation_registry", registry, "array_template",
    {
      "u16",
      { "array_template", { "u16" } },
    }
  )
end


function load()
  local registry = ogse.load_var_safe( "dsh_ogse_relations.relation_registry" )
  if not registry then return end
  log2(
    "[%s]: relation table size is %s", script_name(), table.getn( registry )
  )
  local cnt = 0
  for _, pk in ipairs( registry ) do
    local from, items = unpack( pk )
    cnt = cnt + table.getn( items )
    -- log2(
    --   "[%s]: loading relation table record %s with size %s",
    --   script_name(), from, table.getn( items )
    -- )
    relation_from_to[ from ] = {}
    for _, to in ipairs( items ) do
      ASSERT(
        ( not relation_from_to[ from ][ to ] ),
        "found second record to %s from %s", from, to
      )
      relation_from_to[ from ][ to ] = true
      -- log2( "[%s]: loading relation: %s -> %s", script_name(), from, to )
      if to > 0 then
        if not relation_to_from[ to ] then
          relation_to_from[ to ] = {}
        end
        relation_to_from[ to ][ from ] = true
      end
    end
  end
  log2( "[%s]: relation table loaded: %s items", script_name(), cnt )
end


function clear_personal_record( from, to )
  db.actor:clear_personal_record( from, to )
  if relation_from_to[ from ] then
    relation_from_to[from ][ to ] = nil
  end
end


local friends_comm = {
  [ "ecolog"  ] = true,
  [ "dolg"    ] = true,
  [ "freedom" ] = true,
  [ "green"   ] = true,
  [ "nebo"    ] = true,
  [ "stalker" ] = true,
  [ "trader"  ] = true,
}

function on_npc_spawn( npc, binder )
  if not npc:alive() then return end
  local comm = npc:character_community()
  if not friends_comm[ comm ] then return end
  local p_gw = npc:goodwill( db.actor )
  if p_gw < attitude_neutal_threshold then
    local c_gw = relation_registry.community_goodwill( comm, db.actor:id() )
    if
      c_gw >= attitude_neutal_threshold
      and not (
        relation_from_to[ npc:id() ]
        and relation_from_to[ npc:id() ][ db.actor:id() ]
      )
    then
      log2(
        "[%s]: restore goodwill for %s: goowdill = %s, community_goodwill = %s",
        script_name(), npc:name(), p_gw, c_gw
      )
      npc:set_relation( game_object.neutral, db.actor )
      clear_personal_record( npc:id(), db.actor:id() )
      if npc:character_reputation() < 0 then
        npc:change_character_reputation( 0 - npc:character_reputation() )
      end
      npc:enable_memory_object( db.actor, false )
      xrs_battle_ai.reset_everything( npc )
    end
  end
end


function on_npc_before_hit( obj, hit_data, p_s_hit, p_ignore_flags )
  if
    hit_data.who_id ~= db.actor:id()
    or obj:relation( db.actor ) == game_object.enemy
    or hit_data.power == 0
  then
    return
  end
  local binder = obj:binded_object()
  local t      = binder[ script_name() ]
  if not t then
    t = {}
    binder[ script_name() ] = t
  end
  if t.ff_detected then return end
  t.ff_detected = true
  local gulag = xr_gulag.get_npc_gulag( obj )
  if gulag then
    t.gulag = gulag.name
  end
  local wpn, ammo
  if hit_data.weapon_id then
    wpn = level.object_by_id( hit_data.weapon_id )
    if wpn then
      ammo = dsh.get_cur_wpn_ammo( wpn )
      wpn  = wpn:section()
    end
  end
  log2(
    "[%s]: friendly fire registered: %s, weapon = %s (%s)",
    script_name(), obj:name(), tostring( wpn ), tostring( ammo )
  )
end


local gulags_bad = {
  [ "val_escort"    ] = true,
  [ "val_sacrifice" ] = true
}

function on_npc_death( victim, who )
  if not who then return end
  if who:id() ~= db.actor:id() then return end
  local binder = victim:binded_object()
  local t      = binder[ script_name() ]
  if not ( t and t.ff_detected ) then return end
  if friends_comm[ victim:character_community() ] then
    local timer_name = "dsh_ogse_relations.ff_detected_sms1"
    if not ogse_st_mgr.timer_exists( timer_name ) then
      ogse_st_mgr.start_gtimer( timer_name, 19 * 60 , timer_name )
    end
  end
  if t.gulag and not gulags_bad[ t.gulag ] then
    xr_gulag.setGulagEnemy( t.gulag, db.actor )
  end
end


function ff_detected_sms1()
  db.actor:change_character_reputation( -50 )
  local timer_name = "dsh_ogse_relations.ff_detected_sms2"
  if not ogse_st_mgr.timer_exists( timer_name ) then
    ogse_st_mgr.start_gtimer( timer_name, 5 * 3600 + 11 * 60 , timer_name )
  end
  local name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    "Видел, как один сталкер с харей покорёженной, парня завалил. От такого всё, что хочешь ждать можно.",
    string.format( "%s %s", name, sname ),  0, 5, "uniq", "news"
  )
  name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    "Это кто такой? Знал я одного. Морда ужас! Копчёный или не... На мы букву... В общем понятно всё с таким.",
    string.format( "%s %s", name, sname ), 15, 5, "uniq", "news"
  )
end


function ff_detected_sms2()
  db.actor:change_character_reputation( -250 )
  local name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    string.format(
      "Народ, слыхали? Один сталкер по кличке %s таким козлом оказался! Своих мужиков кидает... Скот.",
      dsh.get_actor_name()
    ),
    string.format( "%s %s", name, sname ),  0, 5, "uniq","news"
  )
  name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    "Да убивать за такое нужно! На месте! Чтоб другим неповадно было!",
    string.format( "%s %s", name, sname ), 15, 5, "uniq", "news"
  )
end


function on_spawn()
  local s = get_string( "game_relations", "reputation" )
  ASSERT( s, "'reputation' not found in [game_relations]" )
  local reputations = parse_names( s )
  ASSERT(
    table.getn( reputations ) > 2,
    "wrong 'reputation' in [game_relations]: %s", s
  )
  local max = tonumber( reputations[ table.getn( reputations ) - 1 ] )
  ASSERT( max, "wrong 'reputation' in [game_relations]: %s", s )
  if db.actor:character_reputation() > max then
    log2(
      "[%s]: adjust actor's character_reputation(): %s -> %s",
      script_name(), db.actor:character_reputation(), max
    )
    db.actor:change_character_reputation(
      max - db.actor:character_reputation()
    )
  end
end
