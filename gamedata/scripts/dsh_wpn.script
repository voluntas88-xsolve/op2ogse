-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_update", fun = this.on_update })
end


local cur_wpn = {}
function on_update( delta )
  local wpn = db.actor:active_item()
  if not wpn then return end
  if not wpn:is_weapon() then return end
  if ( not cur_wpn.id ) or cur_wpn.id ~= wpn:id() then
    local t = {}
    t.ammo_n           = wpn:get_ammo_in_magazine()
    t.dispersion_start = get_u32( wpn:section(), "dispersion_start" )
    t.fire_dispersion_base = get_float( wpn:section(), "fire_dispersion_base", 0 )
    t.has_gl           = has_wpn_gl( wpn )
    t.has_silencer     = ( ogse_wpn_utils.get_silencer_status( wpn ) == 2 )
    t.highfire_mode    = get_u32( wpn:section(), "highfire_mode" )
    t.id               = wpn:id()
    t.lowfire_mode     = get_u32( wpn:section(), "lowfire_mode"  )
    t.rpm              = get_u32( wpn:section(), "rpm"      )
    t.rpm_high         = get_u32( wpn:section(), "rpm_high" )
    t.rpm_low          = get_u32( wpn:section(), "rpm_low"  )
    t.shot_n           = 0
    t.use_aim_bullet   = get_bool( wpn:section(), "use_aim_bullet", false )
    t.weapon_state     = wpn:get_hud_item_state()
    t.wpn              = wpn
    t.zoom_body_state  = "unknown"
    cur_wpn = t
    if cur_wpn.has_gl then
      cur_wpn.gl_mode = ogse_wpn_utils.get_gl_mode( wpn )
      cur_wpn.gl_name = get_string( wpn:section(), "grenade_launcher_name" )
    end
  end
  check_silencer( wpn )
  configure_high_rpm( cur_wpn )
  configure_fire_dispersion( cur_wpn )
  local state = wpn:get_hud_item_state()
  if state == cur_wpn.weapon_state then
    if state == weapon_states.fire then
      local ammo_n = wpn:get_ammo_in_magazine()
      if ammo_n ~= cur_wpn.ammo_n then
        cur_wpn.ammo_n = ammo_n
        cur_wpn.shot_n = cur_wpn.shot_n + 1
        configure_low_rpm( cur_wpn )
        ogse_signals.get_mgr():call( "on_actor_fire", cur_wpn )
      end
    end
  else
    cur_wpn.shot_n = 0
    if cur_wpn.weapon_state == weapon_states.fire then
      configure_low_rpm( cur_wpn )
    end
    if state == weapon_states.fire then
      cur_wpn.ammo_n = wpn:get_ammo_in_magazine()
      cur_wpn.shot_n = cur_wpn.shot_n + 1
      configure_low_rpm( cur_wpn )
      ogse_signals.get_mgr():call( "on_actor_fire", cur_wpn )
    elseif state == weapon_states.switch then
      if cur_wpn.has_gl then
        local gl_mode = ogse_wpn_utils.get_gl_mode( wpn )
        if cur_wpn.gl_mode ~= gl_mode then
          cur_wpn.gl_mode = gl_mode
          ogse_signals.get_mgr():call( "on_wpn_gl_mode", cur_wpn )
        end
      end
    elseif state == weapon_states.reload then
      if
        ( db.actor:is_actor_sprinting() or db.actor:is_actor_climbing() )
        and math.random() < level.get_game_difficulty() * 0.2
      then
        db.actor:drop_item( wpn )
        dsh.say_blin()
      end
    end
    cur_wpn.weapon_state = state
  end
end


function has_wpn_gl( wpn )
  return (
    wpn:is_weapon_gl()
    and (
      ogse_wpn_utils.get_grenade_launcher_status( wpn ) == 1
      or (
        ogse_wpn_utils.get_grenade_launcher_status( wpn ) == 2
        and ogse_wpn_utils.get_grenade_launcher_flag( wpn )
      )
    )
  )
end


function check_silencer( wpn )
  if cur_wpn.has_silencer then
    local silencer_mode = ogse_wpn_utils.get_silencer_flag( wpn )
    if cur_wpn.silencer_mode ~= silencer_mode then
      local def_condition_shot_dec =
        get_float( wpn:section(), "condition_shot_dec" )
      if silencer_mode then
        ogse_wpn_utils.set_condition_shot_dec( wpn, def_condition_shot_dec * 4 )
      else
        ogse_wpn_utils.set_condition_shot_dec( wpn, def_condition_shot_dec )
      end
      cur_wpn.silencer_mode = silencer_mode
      ogse_signals.get_mgr():call( "on_wpn_silencer_mode", cur_wpn )
    end
  end
end


function configure_high_rpm( cur_wpn )
  if cur_wpn.highfire_mode then
    local wpn = cur_wpn.wpn
    local qs  = ogse_wpn_utils.get_queue_size( wpn )
    if ( not cur_wpn.queue_size ) or qs ~= cur_wpn.queue_size then
      local rpm
      if qs == cur_wpn.highfire_mode then
        rpm = 60 / cur_wpn.rpm_high
      else
        rpm = 60 / cur_wpn.rpm
      end
      ogse_wpn_utils.set_time_to_fire( wpn, rpm )
      cur_wpn.queue_size = qs
    end
  end
end


function configure_low_rpm( cur_wpn )
  if cur_wpn.lowfire_mode and cur_wpn.lowfire_mode > 1 then
    local wpn = cur_wpn.wpn
    local rpm
    -- уменьшать время выстрела нужно не после последнего выстрела, а после
    -- предпоследнего, т.к. движок уже вычислил время ожидания и новое время
    -- выстрела вступит в силу только через выстрел.
    if cur_wpn.shot_n < cur_wpn.lowfire_mode - 1 then
      rpm = 60 / cur_wpn.rpm
    else
      rpm = 60 / cur_wpn.rpm_low
    end
    ogse_wpn_utils.set_time_to_fire( wpn, rpm )
  end
end


local def_disp_aim = get_float( "actor", "disp_aim" )

function configure_fire_dispersion( cur_wpn )
  local zoom_bs = get_zoom_body_state()
  if cur_wpn.zoom_body_state ~= zoom_bs then
    local k = zoom_bs == "zoom_crouch" and 0.5
      or ( zoom_bs == "zoom_creep" and 0.25 )
      or 1
    set_disp_aim( math.rad( def_disp_aim * k ) )
    if cur_wpn.use_aim_bullet and cur_wpn.wpn:condition() > 0.9 then
      ogse_wpn_utils.set_fire_dispersion_base(
        cur_wpn.wpn, math.rad( cur_wpn.fire_dispersion_base * k )
      )
    end
    cur_wpn.zoom_body_state = zoom_bs
  end
end


function get_zoom_body_state()
  return zoom_mode() == 1
    and (
      db.actor:is_actor_crouch()
        and "zoom_crouch"
        or (
          db.actor:is_actor_creep() and "zoom_creep"
        )
        or "zoom_normal"
    )
    or "no_zoom"
end


function bind( obj )
  obj:bind_object( wpn_binder( obj ) )
end


class "wpn_binder"( object_binder )
function wpn_binder:__init( obj ) super( obj )
  self.sm = ogse_signals.get_mgr()
  self.sm:call( "on_wpn_init", obj )
end


function wpn_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  self.sm:call( "on_wpn_spawn", self.object )
  return true
end


function wpn_binder:update()
  self:check_gl_mode()
  self.sm:call( "on_wpn_update", self.object )
end


function wpn_binder:net_destroy()
  self.sm:call( "on_wpn_destroy", self.object )
  object_binder.net_destroy( self )
end
