-- -*- mode: lua; coding: windows-1251-dos -*-

function init( obj )
  local new_binder = sg_class_binder( obj )
  obj:bind_object( new_binder )
end


--------------------------------------------------------------------------------
-- Порядок загрузки:
-- reload
-- reinit
-- load
-- net_spawn
--------------------------------------------------------------------------------
class "sg_class_binder" ( object_binder )
function sg_class_binder:__init( obj ) super( obj )
end


function sg_class_binder:reinit()
  object_binder.reinit( self )

  self.ammo_table = rx_utils.parse_list_new(
    nil, self.object:section(), "ammo_class"
  )
  self.ammo_load = {} -- таблица к-ва патронов, инициализируем все типы нулями
  for k, v in pairs( self.ammo_table ) do
    self.ammo_load[ k ] = 0
  end
  self.ammo_class_num = 1
  self.load = 0
end


function sg_class_binder:net_save_relevant()
  return true
end


function sg_class_binder:save( packet )
  ASSERT(
    db.saving_obj == nil ,
    "found saving_obj = %s",
    tostring( db.saving_obj and db.saving_obj:name() or nil )
  )
  db.saving_obj = self.object
  object_binder.save( self, packet )

  -- номер текущего типа патронов в списке (начало с 1)
  self.ammo_class_num = self:get_ammo_type() + 1
  ASSERT(
    self.ammo_class_num <= table.getn( self.ammo_table ),
    "%s: wrong ammo_class_num: %s",
    self.object:name(), self.ammo_class_num
  )
  packet:w_u8( self.ammo_class_num ) -- сразу пишем

  self.load = self.object:get_ammo_in_magazine()
  packet:w_u16( self.load )

  -- читаем update-пакет
  self:update_ammo_loaded()
  ASSERT(
    table.getn( self.ammo_load ) == table.getn( self.ammo_table ),
    "%s: wrong ammo_load table: %s ~= %s",
    self.object:name(), table.getn( self.ammo_load ),
    table.getn( self.ammo_table )
  )
  -- Пишем количества заряженных патронов
  for k, v in pairs ( self.ammo_load ) do
    packet:w_u16( v )
  end

  if utils.level_changing() then
    self.level_changing = true
  end
  db.saving_obj = nil
end


function sg_class_binder:load( reader )
  -- ресет таблицы зарядки
  for k, v in pairs ( self.ammo_load ) do
    self.ammo_load[ k ] = 0
  end
  object_binder.load( self, reader )
  ASSERT( not reader:r_eof(), "unexpected r_eof(): %s", self.object:name() )
  self.ammo_class_num = reader:r_u8()
  ASSERT(
    self.ammo_class_num <= table.getn( self.ammo_table ),
    "%s: wrong ammo_class_num: %s",
    self.object:name(), self.ammo_class_num
  )
  self.load = reader:r_u16()
  for k, v in pairs ( self.ammo_load ) do
    self.ammo_load[ k ] = reader:r_u16()
  end
  self.try_unload = true
end


function sg_class_binder:update( delta )
  if self.try_unload then
    self:unload()
    self.try_unload = false
  end
end


function sg_class_binder:net_destroy()
  local sobj = alife():object( self.object:id() )
  if sobj and not self.level_changing then
    self.ammo_class_num = self:get_ammo_type() + 1
    self.load           = self.object:get_ammo_in_magazine()
    self:update_ammo_loaded()
    self:unload()
  end
  object_binder.net_destroy( self )
end


function sg_class_binder:unload()
  local mag_size = get_u32( self.object:section(), "ammo_mag_size", 0 )
  local elapsed  = self.ammo_load[ self.ammo_class_num ]
  if self.load ~= elapsed or elapsed > mag_size then
    if elapsed > mag_size then elapsed = mag_size end
    -- не все заряженные патроны были текущего типа
    -- оставляем только патроны текущего типа
    self.object:set_ammo_elapsed( elapsed )
    -- их возвращать не надо
    self.ammo_load[ self.ammo_class_num ] =
      self.ammo_load[ self.ammo_class_num ] - elapsed
    -- возврат остальных патронов
    local sobj = alife():object( self.object:id() )
    ASSERT( sobj, "%s not found in alife()", self.object:name() )
    local pk   = get_netpk( sobj, 1 )
    ASSERT( pk:isOk(), "can't read netpacket of %s", sobj:name() )
    local data = pk:get()
    data.ammo_elapsed = elapsed
    pk:set( data )
    local pid = sobj.parent_id
    if pid == 65535 then
      local pos = vector():set(
        sobj.position.x,
        sobj.position.y + 10,
        sobj.position.z
      )
      for k, v in pairs ( self.ammo_load ) do
        if v > 0 then
          se_respawn.create_ammo(
            self.ammo_table[ k ],
            pos, sobj.m_level_vertex_id, sobj.m_game_vertex_id,
            pid, v
          )
        end
      end
    else
      local p_sobj = alife():object( pid )
      if p_sobj then
        for k, v in pairs ( self.ammo_load ) do
          if v > 0 then
            se_respawn.create_ammo(
              self.ammo_table[ k ], vector():set( 0, 0, 0 ), 1, 1, pid, v
            )
          end
        end
      end
    end
  end
end


function sg_class_binder:update_ammo_loaded()
  local sobj = alife():object( self.object:id() )
  ASSERT( sobj, "%s not found in alife()", self.object:name() )
  local pk = get_netpk( sobj, 2 )
  ASSERT( pk:isOk(), "can't read netpacket of %s", sobj:name() )
  local data = pk:get()
  -- ресет таблицы зарядки
  for k, v in pairs ( self.ammo_load ) do
    self.ammo_load[ k ] = 0
  end
  for _, t in ipairs( data.upd.ammo_ids ) do
    -- номер данного типа патронов в списке (начало с 1)
    local round_class = t + 1
    -- нашли патрон такого типа - прибавляем к сумме
    self.ammo_load[ round_class ] = self.ammo_load[ round_class ] + 1
  end
end


function sg_class_binder:get_ammo_type()
  return ogse_wpn_utils.get_active_ammo_type( self.object )
end
