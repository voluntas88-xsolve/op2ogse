-- -*- mode: lua; coding: windows-1251-dos -*-
-----------------------------------------------------------------------
--- ogse_anomaly_evader.script
--- Модуль обхода аномалий
--- KamikaZze, OGS Evolution Team 2011
--- version 1.3 (20/08/2012)
-----------------------------------------------------------------------
--- Настройки схемы
-----------------------------------------------------------------------
local excluded_npc = {
  [ 29 ] = true,                -- учебная плоть блин
  [ "bar_ecolog_professor" ] = true,
  [ "dik_the_drifter"      ] = true,
  [ "zona_brother1"        ] = true,
  [ "zona_brother2"        ] = true,
  [ "val_escort_captive"   ] = true,
  [ "val_escort_nap1"      ] = true,
  [ "bandit_trader"        ] = true,
  [ "bandit_trader_spawn"  ] = true,
  [ "peshera_plennyi"      ] = true,
}

local excluded_sect = {
  [ "burning_fuzz" ] = true,
  [ "zone_rad"     ] = true,
}

local excluded_comms = {        -- запретные коммунити
  [ "zombied" ] = true,
  [ "trader"  ] = true,
}

local excluded_locations = {
  -- [ "l03u_agr_underground" ] = true,
}

local added_restrictions = {}
local last_position      = {}


function attach( sm )
  sm:subscribe({ signal = "on_after_blowout",       fun = this.on_after_blowout })
  sm:subscribe({ signal = "on_monster_death",       fun = this.on_death   })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_death   })
  sm:subscribe({ signal = "on_monster_spawn", fun = this.on_monster_spawn })
  sm:subscribe({ signal = "on_npc_death",           fun = this.on_death   })
  sm:subscribe({ signal = "on_npc_net_destroy",     fun = this.on_death   })
  sm:subscribe({ signal = "on_npc_spawn",     fun = this.on_npc_spawn     })
  sm:subscribe({ signal = "on_spawn", fun = this.on_spawn })
  sm:subscribe({ signal = "on_save",  fun = this.on_save  })
end


function on_monster_spawn( obj, binder )
  added_restrictions[ obj:id() ] = nil
  last_position[ obj:id()      ] = nil
  if not obj:alive() then return end
  if excluded_npc[ obj:story_id() ] then return end
  if excluded_locations[ level.name() ] then return end
  local s = {
    [ "signal" ] = "on_update",
    [ "self"   ] = obj,
    [ "fun"    ] = this.update_norm,
    [ "script_name" ] = script_name(),
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end


function on_npc_spawn( obj, binder )
  added_restrictions[ obj:id() ] = nil
  last_position[ obj:id()      ] = nil
  if not obj:alive() then return end
  if
    excluded_npc[ obj:profile_name() ]
    or excluded_npc[ obj:name() ]
    or excluded_npc[ obj:story_id() ]
    or excluded_comms[ obj:character_community() ]
  then
    return
  end
  if excluded_locations[ level.name() ] then return end
  local s = {
    [ "signal" ] = "on_update",
    [ "self"   ] = obj,
    [ "fun"    ] = this.update_norm,
    [ "script_name" ] = script_name(),
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end


function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ script_name() .. ".subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
    binder[ script_name() .. ".subscribed" ] = nil
  end
  -- cleanup( obj )
  added_restrictions[ obj:id() ] = nil
  last_position[ obj:id() ]      = nil
end


function remove_restriction( npc, anomid )
  local sobj = alife():object( anomid )
  amk_anoms.set_anomaly_status( sobj, "del" )
  for npc_id, anoms in pairs( added_restrictions ) do
    local npc_obj = level.object_by_id( npc_id )
    if npc_obj and anoms[ anomid ] then
      anoms[ anomid ] = nil
      npc_obj:remove_restrictions( "", sobj:name() )
    end
  end
end


function cleanup( obj )
  local nid   = obj:id()
  local anoms = added_restrictions[ nid ]
  if anoms then
    local restrs = {}
    for k, v in pairs( anoms ) do
      local sobj = alife():object( k )
      if sobj then
        table.insert( restrs, sobj:name() )
      end
    end
    if table.getn( restrs ) > 0 then
      local s = table.concat( restrs, "," )
      ASSERT( s:len() < 4096, "too long: %s", s:len() )
      obj:remove_restrictions( "", s )
    end
    added_restrictions[ nid ] = nil
    last_position[ nid ]      = nil
  end
end


-- как часто выполнять обход аномалий (в мс)
local freq = 1000

function update_norm( obj )
  ogse_signals.get_mgr():reschedule( freq + math.random( freq ) )

  local curr_pos = obj:position()
  local prev_pos = last_position[ obj:id() ]
  if prev_pos then
    if prev_pos:distance_to( curr_pos ) < 50 then
      return
    else
      last_position[ obj:id() ] = curr_pos
    end
  else
    last_position[ obj:id() ] = curr_pos
  end

  if not added_restrictions[ obj:id() ] then
    added_restrictions[ obj:id() ] = {}
  end

  local restr = {}
  for _, o in ipairs( amk_anoms.get_anomaly_list( obj, 100 ) ) do
    local sobj = alife():object( o.id )
    if sobj and amk_anoms.get_anomaly_status( sobj ) ~= "del" then
      local sect_anom = sobj:section_name()
      local ignore    = false
      for k, v in pairs( excluded_sect ) do
        if string.find( sect_anom, k ) then
          ignore = true
          break
        end
      end
      if not ignore then
        restr[ sobj:name() ] = true
      end
    end
  end
  
  local del = {}
  for k, _ in pairs( added_restrictions[ obj:id() ] ) do
    if restr[ k ] then
      restr[ k ] = nil -- уже установлен
    else
      table.insert( del, k ) -- удалить старый
    end
  end
  if table.getn( del ) > 0 then
    for _, k in ipairs( del ) do
      added_restrictions[ obj:id() ][ k ] = nil
    end
    local s = table.concat( del, "," )
    ASSERT( s:len() < 4096, "too long: %s", s:len() )
    obj:remove_restrictions( "", s )
  end

  local add = {}
  for k, _ in pairs( restr ) do
    if not should_npc_miss_this_anomaly( obj ) then
      table.insert( add, k )
      added_restrictions[ obj:id() ][ k ] = true
    end
  end
  if table.getn( add ) > 0 then
    local s = table.concat( add, "," )
    ASSERT( s:len() < 4096, "too long: %s", s:len() )
    obj:add_restrictions( "", s )
  end
end


local monster_miss_cnt = 0
function should_npc_miss_this_anomaly( npc )
  local miss_this_anomaly = false
  if IsMonster( npc ) then
    if monster_miss_cnt == 0 then
      miss_this_anomaly = true
      monster_miss_cnt  = init_monster_miss_cnt()
    else
      monster_miss_cnt = monster_miss_cnt - 1
    end
  end
  return miss_this_anomaly
end


function init_monster_miss_cnt()
  return ( 1 + level.get_game_difficulty() ) * 2
end


function on_spawn()
  monster_miss_cnt = ogse.load_var(
    script_name() .. ".monster_miss_cnt", init_monster_miss_cnt()
  )
end


function on_save()
  ogse.save_var(
    script_name() .. ".monster_miss_cnt", monster_miss_cnt, "u8"
  )
end


function pre_blow_off()
  for id, _ in pairs( added_restrictions ) do
    local obj = level.object_by_id( id )
    if obj then
      cleanup( obj )
    end
  end
end


function on_after_blowout()
  last_position = {}
end
