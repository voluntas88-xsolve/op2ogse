-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- Physic objects binding
--
-- Разработчик: Evgeniy Negrobov (Jon) jon@gsc-game.kiev.ua
-- Доработки: Andrey Fidrya (Zmey) af@svitonline.com

function init(obj)
  -- Старые схемы
  local ini = obj:spawn_ini()
  if ini and ini:section_exist( "animation" ) then
    abort(
      "object '%s': animation section is deprecated, use logic + impulse combination",
      obj:name()
    )
    return
  end

  -- Новые схемы
  -- Биндить предмет нет смысла, если у него нет секции logic
  if ( not ini ) or not ini:section_exist( "logic" ) then
    -- Прожектор нужно биндить даже без logic
    if ini and not ini:section_exist( "drop_box" ) then
      if obj:clsid() ~= clsid.projector then
        if obj:clsid() ~= clsid.inventory_box then return end
      end
    end
  end

  db.storage[ obj:id() ] = {}
  local new_binder = generic_physics_binder( obj )
  obj:bind_object( new_binder )
end


class "generic_physics_binder" ( object_binder )
function generic_physics_binder:__init( obj ) super( obj )
  self.am          = ogse_signals.get_mgr()
  self.initialized = false
  self.loaded      = false
end


function generic_physics_binder:reload( section )
  object_binder.reload( self, section )
end


function generic_physics_binder:reinit()
  object_binder.reinit( self )
  db.storage[ self.object:id() ] = {}
  self.st = db.storage[ self.object:id() ]
  self.health = self.object:get_car() and self.object:get_car():GetfHealth()
end


function generic_physics_binder:update( delta )
  object_binder.update( self, delta )

  if not self.initialized and db.actor then
    self.initialized = true
    xr_logic.initialize_obj(
      self.object, self.st, self.loaded, db.actor, modules.stype_item
    )
    --' Запускаем ассоциированный с объектом партикл.
    local particle = utils.cfg_get_string(
      self.st.ini, self.st.section_logic, "particle", self.object, false, "", nil
    )
    if particle ~= nil then
      self.particle = particles_object( particle )
      self.particle:play_at_pos( self.object:position() )
    end
    --' Дизаблим ассоциированный с объектом граф
    local graph_point_marker = utils.cfg_get_string(
      self.st.ini, self.st.section_logic, "graph_point_marker", self.object, false, "", nil
    )
    if graph_point_marker ~= nil then
      self.disable_graph_point = patrol( graph_point_marker ):game_vertex_id( 0 )
      game_graph():accessible( self.disable_graph_point, false )
    end
  end

  if
    self.st.active_section ~= nil
    or (
      self.object:spawn_ini() ~= nil
      and self.object:spawn_ini():section_exist( "drop_box" ) == true
    )
    or self.object:clsid() == clsid.inventory_box
  then
    xr_logic.issue_event(
      self.object, self.st[self.st.active_scheme], "update", delta
    )
    self.object:set_callback(
      callback.hit, generic_physics_binder.hit_callback, self
    )
    self.object:set_callback(
      callback.death, generic_physics_binder.death_callback, self
    )
    self.object:set_callback(
      callback.use_object, generic_physics_binder.use_callback, self
    )
    -- для бтра hit_callback и death_callback не вызывается. заткнём эти дырки.
    if self.health and not self.nofixonhit then
      local health = self.object:get_car()
        and self.object:get_car():GetfHealth()
      if health then
        if health < 0 then
          self:btr_death_callback()
        elseif self.health - health > 0.001 then
          self.health = health
          self:hit_callback(
            self.object, self.health - health, vector():set( 1, 0, 0), db.actor,
            0
          )
          self.nofixonhit = nil
        end
      end
    end
  end

  self.am:call( "on_physic_obj_update", self.object, delta )
  self.am:call(
    "on_ph_update." .. self.object:id(), self.object, delta
  )
end


function generic_physics_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then return false end
  if self.object:clsid() == clsid.projector then
    db.add_sl( self.object )
  end
  if string.find( self.object:section(), "vehicle_btr" ) then
    db.add_btr( self.object )
  end
  if
    self.object:spawn_ini() ~= nil
    and self.object:spawn_ini():section_exist( "drop_box" ) == true
  then
    self.box_items = xr_box.ph_item_box( self.object )
  end
  amk.on_net_spawn( self.object )
  self.am:call( "on_ph_spawn", self.object, self )
  return true
end


function generic_physics_binder:net_destroy()
  local st = db.storage[ self.object:id() ]
  if st.active_scheme then
    xr_logic.issue_event( self.object, st[ st.active_scheme ], "net_destroy" )
  end
  if self.particle ~= nil then self.particle:stop() end
  db.del_sl( self.object )
  db.storage[ self.object:id() ] = nil
  if string.find( self.object:section(), "vehicle_btr" ) then
    db.del_btr( self.object )
  end
  self.object:set_callback( callback.hit, nil )
  self.object:set_callback( callback.death, nil )
  self.object:set_callback( callback.use_object, nil )
  self.am:call( "on_ph_net_destroy", self.object, self )
  self.am:cleanup_signal_subs( "on_ph_update." .. self.object:id() )
  object_binder.net_destroy( self )
end


function generic_physics_binder:net_save_relevant()
  return true
end


function generic_physics_binder:save( packet )
  ASSERT(
    db.saving_obj == nil ,
    "found saving_obj = %s",
    tostring( db.saving_obj and db.saving_obj:name() or nil )
  )
  db.saving_obj = self.object
  object_binder.save( self, packet )
  xr_logic.save_obj( self.object, packet )
  db.saving_obj = nil
end


function generic_physics_binder:load( reader )
  self.loaded = true
  object_binder.load( self, reader )
  xr_logic.load_obj( self.object, reader )
end


function generic_physics_binder:use_callback( obj, who )
  if self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "use_callback", obj, who
    )
  end
  fly.returner_clear_pos()
  amk.on_use( obj, who )
  amk_utils.physics_use( obj, who )
  self.am:call( "on_ph_obj_use", self.object, who )
end


function generic_physics_binder:hit_callback( obj, amount, local_direction, who, bone_index )
  amk_utils.physics_hit( obj, amount, local_direction, who, bone_index )
  self.nofixonhit = true
  if self.st.ph_on_hit then
    xr_logic.issue_event(
      self.object, self.st.ph_on_hit, "hit_callback", obj, amount,
      local_direction, who, bone_index
    )
  end
  if self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "hit_callback", obj, amount,
      local_direction, who, bone_index
    )
  end
end


function generic_physics_binder:death_callback( victim, who )
  if self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "death_callback", victim,
      who
    )
  end
  if self.particle ~= nil then self.particle:stop() end
  if self.disable_graph_point ~= nil then
    game_graph():accessible( self.disable_graph_point, true )
  end
  if self.box_items then
    self.box_items:spawn_items()
  end
  amk_utils.physics_death( victim, who )
end


function generic_physics_binder:btr_death_callback()
  if string.find( self.object:section(), "vehicle_btr" ) then
    db.del_btr( self.object )
    xr_statistic.addKillCount( db.actor, self.object )
    if self.object:position():distance_to( db.actor:position() ) < 10 then
      local h = hit()
      h.draftsman = db.actor
      h.direction = vector_rotate_y( db.actor:direction(), 180 )
      h:bone( "bip01_spine" )
      h.type      = hit.explosion
      h.power     = 1000
      h.impulse   = 2000
      db.actor:hit( h )
    end
  end
end
