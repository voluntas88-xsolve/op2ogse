-- -*- mode: lua; coding: windows-1251-dos -*-
-- solid_list основан на Linspiro Addon v1.1

local rare_list = {
  novice_section = {
    "wpn_toz34",
    "wpn_ak74",
    "wpn_mp5_m1",
    "wpn_colt_m1",
    "wpn_mp5_m2",
    "wpn_walther_m1",
    "wpn_fort_m1",
    "wpn_izh43",
    "scientific_outfit",
    "stalker_outfit_v3",
    "specops_outfit",
    "dolg_gaz_outfit_m1",
    "ammo_12x70_buck",
    "ammo_5.45x39_fmj",
    "ammo_9x39_pab9",
    "ammo_9x39_ap",
    "ammo_9x39_sp5",
    "mutant_flesh_eye",
    "mutant_boar_leg",
    "mutant_dog_tail",
    "mutant_zombie_hand",
    "mutant_face_tushkano",
    "mutant_tail_cat",
    "mutant_spleen_rat",
    "mutant_plague_hand",
    "af_medusa",
    "af_vyvert",
    "af_blood",
    "af_electra_sparkler",
    "af_rusty_thorn",
    "af_ameba_slime",
    "af_drops",
    "af_ameba_mica",
    "af_soul",
    "af_night_star",
    "af_electra_moonlight",
    "af_gravi",
    "af_cristall_flower",
    "af_mincer_meat",
    "af_electra_flash",
    "af_rusty_kristall",
    "af_ameba_slug",
    "af_fireball",
    "medkit",
    "outfit_soldier_m1",
    "neytral_novice_outfit_m1",
    "neytral_novice_outfit_new",
    "neytral_novice_outfit_cam_1",
    "neytral_novice_outfit_cam_2",
    "neytral_novice_outfit_cam_3",
    "bandit_outfit",
    "bandit_outfit_blue",
    "bandit_outfit_red",
    "mushroom",
    "fake_wpn_knife",
    "sigaret",
    "ammo_9x19_pbp",
    "ammo_11.43x23_hydro",
    "ammo_zhekan_izomorf",
    "mutant_tushkano_cocoon",
    "mutant_dog_cocoon",
    "mutant_psevdodog_cocoon",
    "mutant_flesh_cocoon",
    "mutant_cat_cocoon",
    "mutant_boar_cocoon",
  },

  experienced_section = {
    "ammo_7.62x54_7h1",
    "ammo_7.62x54_ap",
    "ammo_7.62x54_7h14",
    "ammo_12x70_buck",
    "ammo_5.45x39_fmj",
    "ammo_9x39_pab9",
    "ammo_9x39_ap",
    "ammo_9x39_sp5",
    "ammo_og-7b",
    "ammo_5.45x39_izomorf",
    "ammo_7.62x39_ap",
    "ammo_7.62x51box",
    "mutant_zombie_hand",
    "mutant_snork_leg",
    "mutant_poltergeist_glas",
    "mutant_fracture_hand",
    "mutant_boar_leg",
    "mutant_carlic_hand",
    "part_tarakan_strong",
    "mutant_vypolzen_hrebet",
    "wpn_m16a2_sk1",
    "wpn_sg552_sk1",
    "wpn_wincheaster1300",
    "wpn_m4",
    "wpn_ppsh41_sk2",
    "wpn_abakan_m1",
    "wpn_fort_m1",
    "wpn_winchester_m1",
    "wpn_l85_m1",
    "wpn_l85_m2",
    "wpn_beretta_m1",
    "wpn_izh43",
    "military_outfit",
    "svoboda_heavy_outfit",
    "dolg_scientific_outfit",
    "freedom_scientific_outfit",
    "merc_scientific_outfit",
    "monolit_scientific_outfit",
    "nebo_scientific_outfit",
    "outfit_dolg_m1",
    "outfit_killer_m1",
    "af_ameba_mica",
    "af_ameba_slime",
    "af_ameba_slug",
    "af_babka_1",
    "af_blood",
    "af_cristall_flower",
    "af_drops",
    "af_dummy_battery",
    "af_dummy_dummy",
    "af_dummy_glassbeads",
    "af_dummy_pellicle",
    "af_dummy_spring",
    "af_electra_flash",
    "af_electra_moonlight",
    "af_electra_sparkler",
    "af_fireball",
    "af_fuzz_kolobok",
    "af_gravi",
    "af_medusa",
    "af_mincer_meat",
    "af_night_star",
    "af_rusty_kristall",
    "af_rusty_sea-urchin",
    "af_rusty_thorn",
    "af_soul",
    "af_spirit_1",
    "af_vyvert",
    "medkit_army",
    "mutant_zombie_cocoon",
    "mutant_snork_cocoon",
    "mutant_poltergeist_cocoon",
    "amk_kanistra",
  },

  veteran_section = {
    "af_ameba_mica",
    "af_ameba_slime",
    "af_ameba_slug",
    "af_armor_1",
    "af_armor_2",
    "af_babka_1",
    "af_blood",
    "af_cristall_flower",
    "af_cry_1",
    "af_dik_1",
    "af_drops",
    "af_dummy_battery",
    "af_dummy_dummy",
    "af_dummy_glassbeads",
    "af_dummy_pellicle",
    "af_dummy_spring",
    "af_electra_flash",
    "af_electra_moonlight",
    "af_electra_sparkler",
    "af_eye_voron",
    "af_fireball",
    "af_fuzz_kolobok",
    "af_gravi",
    "af_kol_1",
    "af_medusa",
    "af_mincer_meat",
    "af_night_star",
    "af_pudd_1",
    "af_pudd_2",
    "af_rusty_kristall",
    "af_rusty_sea-urchin",
    "af_rusty_thorn",
    "af_soul",
    "af_spirit_1",
    "af_spirit_2",
    "af_vyvert",
    "ammo_og-7b",
    "ammo_vog-25p",
    "ammo_7.62x54_7h1",
    "ammo_7.62x54_ap",
    "ammo_7.62x54_7h14",
    "ammo_12x70_buck",
    "ammo_5.45x39_fmj",
    "ammo_9x39_pab9",
    "ammo_9x39_ap",
    "ammo_9x39_sp5",
    "ammo_9x39_izomorf",
    "ammo_minigun",
    "ammo_5.56x45_ap",
    "ammo_20x85",
    "ammo_7.62x51_ap",
    "ammo_gauss",
    "nebo_exo_outfit",
    "mutant_krovosos_jaw",
    "mutant_burer_hand",
    "mutant_zombie_hand",
    "mutant_hand_kontroler",
    "mutant_psevdogigant_hand",
    "mutant_chimera_kogot",
    "mutant_spider_gland",
    "mutant_rotan_heart",
    "mutant_zanoza_leg",
    "wpn_spas12",
    "wpn_m1891_30_scope",
    "wpn_groza",
    "medkit_scientic",
    "mutant_krovosos_cocoon",
    "mutant_burer_cocoon",
    "mutant_chimera_cocoon",
    "amk_ballon",
  },

  master_section = {
    "wpn_spas12",
    "wpn_groza",
    "wpn_val",
    "wpn_val_m1",
    "wpn_vintorez",
    "wpn_protecta",
    "wpn_g3_otdaca_ves",
    "wpn_scar_792",
    "wpn_k98",
    "wpn_rpk74_sk1",
    "wpn_g41",
    "wpn_sr25_mk11_mod0_sk1",
    "wpn_zastava_m76",
    "wpn_m1891_30_scope",
    "wpn_rg-6",
    "wpn_rg6_m1",
    "wpn_peceneg",
    "wpn_m16a2_sk12",
    "wpn_pps43",
    "wpn_usas12",
    "wpn_mkb_42",
    "wpn_svt40",
    "wpn_mg42",
    "wpn_kedr",
    "wpn_ump45",
    "wpn_m93r",
    "wpn_oc33_sk1",
    "wpn_svu",
    "wpn_p90",
    "wpn_fn2000",
    "wpn_mp153",
    "wpn_mp153pract",
    "wpn_browningauto5",
    "wpn_benelli_m3_tactik",
    "wpn_fn_fal_c1",
    "wpn_scar_mk17",
    "wpn_ak12",
    "wpn_g36_m1",
    "wpn_ak103",
    "wpn_br1935",
    "wpn_val_m2",
    "wpn_aek971",
    "wpn_aek973_pso1",
    "wpn_9a91",
    "wpn_g3_nogl",
    "wpn_mg4",
    "wpn_vihr",
    "wpn_colt1911_m1",
    "wpn_colt1911_m2",
    "wpn_fnp45_m1",
    "wpn_scar_acog",
    "wpn_scar_m1",
    "wpn_wa2000",
    "mutant_burer_red_hand",
    "mutant_deathclaw_antler",
    "mutant_raptor_kogot",
    "mutant_plague_hand",
    "mutant_vypolzen_hrebet",
    "mutant_spider_gland",
    "mutant_rotan_heart",
    "mutant_zanoza_leg",
    "mutant_carlic_hand",
    "mutant_krovosos_red_jaw",
    "mutant_zombie_hand",
    "part_digitis_biblio",
    "part_tarakan_strong",
    "bezoar",
    "mozg",
    "red_mozg",
    "rudiment_big",
    "mutant_babka_cocoon",
    "mutant_bibliotekar_cocoon",
    "mutant_big_cocoon",
    "mutant_bloodsucker_cocoon",
    "mutant_bloodsucker2_cocoon",
    "mutant_boar_cocoon",
    "mutant_burer_cocoon",
    "mutant_cat_cocoon",
    "mutant_chimera_cocoon",
    "mutant_controller_cocoon",
    "mutant_deathclaw_cocoon",
    "mutant_dog_cocoon",
    "mutant_electro_cocoon",
    "mutant_flesh_cocoon",
    "mutant_fracture_cocoon",
    "mutant_ghost_cocoon",
    "mutant_gigant_cocoon",
    "mutant_jumper_cocoon",
    "mutant_kachok_cocoon",
    "mutant_krovosos_cocoon",
    "mutant_mono_cocoon",
    "mutant_poltergeist_cocoon",
    "mutant_psevdodog_cocoon",
    "mutant_psydog_cocoon",
    "mutant_rat_cocoon",
    "mutant_snork_cocoon",
    "mutant_tarakan_cocoon",
    "mutant_tarakan2_cocoon",
    "mutant_tushkano_cocoon",
    "mutant_x_ray_cocoon",
    "mutant_zombie_cocoon",
    "ammo_7.62x39_k",
    "ammo_7.62x54_7h1",
    "ammo_7.62x54_ap",
    "ammo_7.62x54_7h14",
    "ammo_7.62x54_izomorf",
    "ammo_12x76_zhekan",
    "ammo_12x76_dart",
    "ammo_zhekan_izomorf",
    "ammo_og-7b",
    "grenade_f1",
    "grenade_rgd5",
    "ammo_balon",
    "ammo_12.7x108",
    "ammo_gauss",
    "ammo_super_gauss",
    "ammo_5.45x39_ap",
    "ammo_5.45x39_izomorf",
    "ammo_9x39_pab9",
    "ammo_9x39_ap",
    "ammo_9x39_sp5",
    "ammo_9x39_izomorf",
    "amk_kanistra",
    "amk_ballon",
    "svoboda_exoskeleton",
    "nebo_exo_outfit",
    "nebo_scientific_outfit",
    "nebo_heavy_outfit",
    "exo_bandit_outfit",
    "voen_exo_outfit",
    "exo_scientist_outfit",
    "exo_outfit",
    "dolg_black_exoskeleton",
    "killer_green_exoskeleton",
    "killer_outfit",
    "seva_scient_outfit",
    "broken_exoskeleton",
    "killer_blue_exoskeleton",
    "outfit_lethalspeed_exo_m1",
    "outfit_lethalspeed_exo_m2",
    "scientist_suit_white",
    "af_ameba_mica",
    "af_ameba_slime",
    "af_ameba_slug",
    "af_armor_1",
    "af_armor_2",
    "af_armor_3",
    "af_babka_1",
    "af_babka_2",
    "af_babka_3",
    "af_blood",
    "af_cristall_flower",
    "af_cry_1",
    "af_cry_2",
    "af_dik_1",
    "af_dik_2",
    "af_drops",
    "af_dummy_battery",
    "af_dummy_dummy",
    "af_dummy_glassbeads",
    "af_dummy_pellicle",
    "af_dummy_spring",
    "af_electra_flash",
    "af_electra_moonlight",
    "af_electra_sparkler",
    "af_eye_voron",
    "af_fireball",
    "af_fuzz_kolobok",
    "af_gravi",
    "af_kol_1",
    "af_kol_2",
    "af_kol_3",
    "af_medusa",
    "af_mincer_meat",
    "af_night_star",
    "af_pero",
    "af_pudd_1",
    "af_pudd_2",
    "af_pudd_2",
    "af_rusty_kristall",
    "af_rusty_sea-urchin",
    "af_rusty_thorn",
    "af_simbion",
    "af_soul",
    "af_spirit_1",
    "af_spirit_2",
    "af_spirit_2",
    "af_vyvert",
    "artifact_electro_crystal_thorn",
    "caps_ameba",
    "caps_electra",
    "caps_gravi",
    "caps_mosquito_bald",
    "caps_mincer",
    "caps_ice",
    "caps_zharka",
    "maz",
    "antizombie",
    "medkit_scientic",
    "treasure_item",
    "playboy1",
    "playboy2",
    "playboy3",
    "playboy4",
    "playboy5",
    "playboy6",
    "playboy7",
    "playboy8",
    "playboy9",
    "playboy11",
    "playboy12",
    "playboy13",
    "ekza_akkumul",
  }
}


function attach( sm )
  sm:subscribe({ signal = "on_ph_obj_use", fun = this.on_treasure_use })
  sm:subscribe({ signal = "on_save",       fun = this.save            })
  sm:subscribe({ signal = "on_spawn",      fun = this.on_spawn        })
end


function on_treasure_use( obj, who )
  if obj:is_inventory_box() and obj:story_id() then
    get_treasure_manager():treasure_empty( obj, obj:story_id() )
  end
end


local given_onetime = {}
function on_spawn()
  local given = ogse.load_var_safe( script_name() .. ".given_onetime" )
  if given then
    for _, sect in ipairs( given ) do
      given_onetime[ sect ] = true
    end
  end
end


function remember_given_onetime( sect )
  given_onetime[ sect ] = true
  local given = {}
  for k, _ in pairs( given_onetime ) do
    table.insert( given, k )
  end
  ogse.save_var(
    script_name() .. ".given_onetime", given, "array_template", { "string" }
  )
end


local treasure_manager
local n_rank


function parse_spawns( line )
  if line == nil then
    return {}
  end

  -- если default-ов больше, чем значений в ini, то забить недостающие
  -- последним значением из ini
  local t = se_respawn.parse_names( line )
  local n = table.getn( t )
  local ret_table = {}
  local k = 1

  while k <= n do
    local spawn   = {}
    spawn.section = t[ k ]
    -- Проверяем что это не последняя запись
    if t[ k + 1 ] ~= nil then
      local p = tonumber( t[ k + 1 ] )
      -- проверяем что вторым числом задана вероятность, а не другая
      -- секция спавну
      if p then
        -- забиваем число
        spawn.prob = p
        k = k + 2
      else
        -- забиваем дефолт 1
        spawn.prob = 1
        k = k + 1
      end
    else
      spawn.prob = 1
      k = k + 1
    end
    table.insert( ret_table, spawn )
  end

  return ret_table
end


class "CTreasure"
function CTreasure:__init()
  --' Итерируемся по всем настройкам фраз
  ASSERT(
    sys_ini:section_exist( "treasure_manager.list" ),
    "There is no section [list] in treasure_manager.ltx"
  )

  local n = sys_ini:line_count( "treasure_manager.list" )
  local result, id, value = 0, "", ""

  --' начальная установка
  self.treasure_info = {}
  for i = 0, n - 1 do
    result, id, value = sys_ini:r_line( "treasure_manager.list", i, "", "" )
    local info  = {}
    local id_sect = "treasure_manager." .. id
    info.target = get_u32( id_sect, "target" )
    info.named  = get_bool( id_sect, "named", false )
    info.name   = get_string( id_sect, "name" )
    info.cond   = xr_logic.parse_condlist(
      db.actor, "treasure_manager", "condlist",
      get_string( id_sect, "condlist", "" )
    )
    --' Отметим тайник как новый
    info.active = false
    info.done   = false
    self.treasure_info[ id ] = info
  end

  --' Вспомогательные таблицы для облегчения поиска
  self.treasure_by_target = {}
  local cnt = 0
  for k, v in pairs( self.treasure_info ) do
    self.treasure_by_target[ v.target ] = k
    cnt = cnt + 1
  end
  ASSERT( n == cnt, "wrong num of loaded items: %s ~= %s", n, cnt )
end


--' Юзание инициатора (возможность выдать тайник)
function CTreasure:use( npc )
  --lootmoney start
  if npc and db.actor then
    lootmoney.lootmoney( npc )
  end
  --lootmoney end

  if npc then
    n_rank = npc:character_rank()
  else
    n_rank = 0
  end
  local rarets = amk.is_debug and 0 or 99

  if dsh.get_next_random( script_name() .. ".rnd", 100 ) < rarets then
    return
  end

  --' Нужно рандомно выбрать один из тайников.
  local avail  = {}
  local tr_sum = 0
  for k, v in pairs( self.treasure_info ) do
    if ( not v.done ) and ( not v.active ) then
      local treasure_prob = xr_logic.pick_section_from_condlist(
        db.actor, npc, v.cond
      )
      if treasure_prob == "" or treasure_prob == nil then
        treasure_prob = 0
      end
      treasure_prob = tonumber( treasure_prob )
      if treasure_prob > 0 and not v.active then
        if treasure_prob == 100 then
          self:give_treasure( k )
        else
          table.insert( avail, { k = k, prob = treasure_prob } )
          tr_sum = tr_sum + treasure_prob
        end
      end
    end
  end
  if tr_sum == 0 then return end

  local tr_w = dsh.get_next_random( script_name() .. ".rnd", tr_sum )
  for k, v in pairs( avail ) do
    tr_w = tr_w - v.prob
    if tr_w <= 0 then
      --' Выдать тайник
      self:give_treasure( v.k )
      break
    end
  end
end


--' Сохранение
function CTreasure:check()
  --' Проверка тайников
  for k, v in pairs( self.treasure_info ) do
    --' Выдать тайник
    self:give_treasure( k )
  end
end


--' Напоминания об активных тайниках на текущей территории
function CTreasure:remind()
  local have = false
  local sms  = "%c[255,160,160,160]Тайники:\\n"
  for k, v in pairs( self.treasure_info ) do
    if v.active then
      local sobj = alife():story_object( v.target )
      if
        sobj and object_level_name( sobj ) == level.name()
        and dsh.map_has_treasure_spot( sobj.id )
      then
        sms  = sms .. "%c[170,200,200,200]" .. game.translate_string( v.name ) .. "\\n"
        have = true
      end
    end
  end
  if have then
    local task_texture, task_rect = get_texture_info( "ui_iconsTotal_abstract5" )
    db.actor:give_game_news( sms, task_texture, task_rect, 0, 5000 )
  end
end


--' Выдача тайника
function CTreasure:give_treasure( k, silent, skip_onetime_items )
  local v    = self.treasure_info[ k ]
  local obj = alife():story_object( v.target )
  if obj then
    ASSERT(
      obj:clsid() == clsid.inventory_box,
      "Story object [%s] is not an inventory box", v.target
    )

    if not silent then
      news_manager.send_treasure( v.name )
      --' Пометить на карте
      local text = "%c[255,238,155,23]"
        .. game.translate_string( v.name ) .. "\\n"
        .. "%c[default]" .. game.translate_string(
          get_string( "treasure_manager." .. k, "description", "" )
      )
      dsh.map_add_treasure( obj.id, "treasure", text )
    end

    -- проверка, какой тип тайника выбран
    -- если тайник не именной, то заменим содержимое
    if v.named then
      v.items = parse_spawns(
        get_string( "treasure_manager." .. k, "items", "" )
      )
    else
      v.items = self:give_item_list( skip_onetime_items )
    end

    --' Сгенерить вещи
    for kk, vv in pairs( v.items ) do
      local prop = amk_utils.get_item_props( vv.section )
      vv.id = {}
      for i = 1, vv.prob do
        local sect = vv.section
        if dsh.is_artefact( sect ) then
          if prop.has_af_dyn then
            sect = amk_anoms.make_dyn_art_sect( sect )
            prop = amk_utils.get_item_props( sect )
          end
          if math.random() > 0.5 + level.get_game_difficulty() / 10 then
            if prop.af_bio_sect then sect = prop.af_bio_sect end
          end
        end
        local sobj = alife():create(
          sect,
          obj.position, obj.m_level_vertex_id, obj.m_game_vertex_id,
          obj.id
        )
        table.insert( vv.id, sobj.id )
      end
    end

    --' Пометим тайник как выданный
    self.treasure_info[ k ].active = true
    self.treasure_info[ k ].done   = true
    -- Отправим тайник в оффлайн
    local sim = alife()
    if sim and obj.online then
      sim:set_switch_online( obj.id, false )
      sim:set_switch_offline( obj.id, true )
      -- ставим в очередь на вывод в онлайн
      amk.convert_npc_timer( obj.id, 1 ):start()
    end
    return v.items
  else
    log2( "TREASURE %s, target doesnt exist", k )
  end
end


--' Снимаем отметку с тайника
function CTreasure:treasure_empty( box, box_story_id )
  local k = self.treasure_by_target[ box_story_id ]
  if ( not k ) or ( not self.treasure_info[ k ] ) then
    return
  end
  self.treasure_info[ k ].active = false
  -- если тайник не именной, то переведен его в онлайн для следующей выдачи
  if not self.treasure_info[ k ].named then
    self.treasure_info[ k ].done = false
  end
  if box then
    dsh.map_remove_treasure( box:id(), "treasure" )
  end
  ogse_signals.get_mgr():call( "on_treasure_empty", box, box_story_id )
end


function CTreasure:is_active( sobj )
  local k = self.treasure_by_target[ sobj.m_story_id ]
  if k and self.treasure_info[ k ] then
    return self.treasure_info[ k ].active
  end
  return false
end


-- Сохранение
function CTreasure:save( p )
  local treasures = {}
  local active_cnt, done_cnt = 0, 0
  for k, v in pairs( self.treasure_info ) do
    -- пишем состояние только активных тайников
    if v.active or v.done then
      table.insert( treasures, { v.target, v.active, v.done } )
      if v.active then active_cnt = active_cnt + 1 end
      if v.done   then done_cnt   = done_cnt   + 1 end
    end
  end
  ogse.save_var(
    script_name() .. ".treasures", treasures, "array_template",
    { "u16", "bool", "bool" }
  )
  log2(
    "[%s]: %s treasures saved (active/done): %s/%s",
    script_name(), table.getn( treasures ), active_cnt, done_cnt
  )
end


-- Загрузка
function CTreasure:load( p )
  local treasures = ogse.load_var_safe( script_name() .. ".treasures" )
  if not treasures then return self:load_old( p ) end
  local active_cnt, done_cnt = 0, 0
  for _, item in ipairs( treasures ) do
    local id, active, done = unpack( item )
    local k    = self.treasure_by_target[ id ]
    local info = self.treasure_info[ k ]
    info.active = active
    info.done   = done
    if active then active_cnt = active_cnt + 1 end
    if done   then done_cnt   = done_cnt   + 1 end
  end
  log2(
    "[%s]: %s treasures loaded (active/done): %s/%s",
    script_name(), table.getn( treasures ), active_cnt, done_cnt
  )
end

local dsh_save_var_name = "treasure_manager.treasure_info"
function CTreasure:load_old( p )
  if ogse.var_exists( dsh_save_var_name ) then
    p = ogse.load_var( dsh_save_var_name )
  end
  local active, done = 0, 0
  local t = p:r_u16()
  for i = 1, t do
    local k    = self.treasure_by_target[ p:r_u16() ]
    local info = self.treasure_info[ k ]
    info.active = p:r_bool()
    info.done   = p:r_bool()
    if info.active then active = active + 1 end
    if info.done   then done   = done   + 1 end
  end
  log2(
    "[%s]: %s treasures loaded (active/done): %s/%s",
    script_name(), t, active, done
  )
  ogse.delete_var( dsh_save_var_name )
end


function CTreasure:give_item_list( skip_onetime_items )
  local rank  = 1
  local tabla = {}
  -- сколько наименований предметов будет в тайнике
  local i     = dsh.get_next_random( script_name() .. ".rnd", 1, 4 )

  -- определим ранг непися
  if n_rank == nil then
    n_rank = dsh.get_next_random( script_name() .. ".rnd", 1, 12 ) * 100
  end
  if n_rank <= 300 then
    rank = 1
  elseif n_rank <=600 then
    rank = 2
  elseif n_rank <= 900 then
    rank = 3
  else
    rank = 4
  end

  -- определим, из какой секции брать предметы, и какие именно
  local sect
  if rank == 1 then
    sect = rare_list.novice_section
  elseif rank == 2 then
    sect = rare_list.experienced_section
  elseif rank == 3 then
    sect = rare_list.veteran_section
  else
    sect = rare_list.master_section
  end

  local items = {}
  for _, item in ipairs( sect ) do
    if
      ( not skip_onetime_items )
      or get_string( item, script_name() .. ".item_is", "" ) ~= "onetime"
    then
      if not given_onetime[ item ] then
        table.insert( items, item )
      end
    end
  end

  for j = 1, i do
    local cnt     = 0
    local spawn   = {}
    spawn.section = items[
      dsh.get_next_random( script_name() .. ".rnd", table.getn( items ) )
    ]
    -- установка кол-ва предметов в зависимости от секции
    local s   = tostring( spawn.section )
    local cls = get_string( s, "class" )
    if get_string( s, script_name() .. ".item_is", "" ) == "onetime" then
      cnt = 1
      remember_given_onetime( s )
    elseif get_string( s, script_name() .. ".item_is", "" ) == "unique" then
      cnt = 1
    elseif ammo_section( s ) then -- патроны
      cnt = dsh.get_next_random( script_name() .. ".rnd", 1, 3 )
    elseif
      cls == "E_STLK" or cls == "W_SILENC" or cls == "W_GLAUNC"
      or string.find( cls, "WP_" )
    then                        -- броники, оружие
      cnt = 1
    elseif
      string.find( s, "^mutant_" ) or string.find( s, "^part_" )
    then
      cnt = dsh.get_next_random( script_name() .. ".rnd", 1, 2 )
    elseif dsh.is_artefact( s ) then -- артефакты
      cnt = 1
    else
      cnt = dsh.get_next_random( script_name() .. ".rnd", 1, 5 )
    end
    -- сохраняем инфу о текущем предмете
    spawn.prob = cnt
    table.insert( tabla, spawn )
  end

  return tabla
end


function get_treasure_manager()
  if not treasure_manager then
    treasure_manager = CTreasure()
  end
  return treasure_manager
end


function take_item_from_box( box, box_story_id )
  -- log2( "!!! take item from box %s", tostring( box:is_inv_box_empty() ) )
  get_treasure_manager():treasure_empty( box, box_story_id )
end


function save()
  get_treasure_manager():save()
end

function load( p )
  get_treasure_manager():load( p )
end

function clear_treasure_manager()
  treasure_manager = nil
end


function CTreasure:dialog( npc )
  if npc then
    n_rank = npc:character_rank()
  else
    n_rank = 0
  end

  local avail  = {}
  local tr_sum = 0
  for k, v in pairs( self.treasure_info ) do
    if ( not v.done ) and ( not v.active ) then
      local treasure_prob = xr_logic.pick_section_from_condlist(
        db.actor, npc, v.cond
      )
      if treasure_prob == "" or treasure_prob == nil then
        treasure_prob = 0
      end
      if tonumber( treasure_prob ) > 0 and v.active == false then
        if tonumber( treasure_prob ) == 100 then
          self:give_treasure( k )
        else
          table.insert( avail, { k = k, prob = treasure_prob } )
          tr_sum = tr_sum + treasure_prob
        end
      end
    end
  end

  if tr_sum == 0 then
    return
  end
  local tr_w = dsh.get_next_random( script_name() .. ".rnd", tr_sum )
  for k, v in pairs( avail ) do
    tr_w = tr_w - v.prob
    if tr_w <= 0 then
      self:give_treasure( v.k )
      break
    end
  end
end


function is_active( sobj )
  return get_treasure_manager():is_active( sobj )
end


function CTreasure:give_rnd_treasure_on_level( lname )
  local avail  = {}
  local tr_sum = 0
  for k, v in pairs( self.treasure_info ) do
    if ( not v.done ) and ( not v.active ) and ( not v.named ) then
      local sobj = alife():story_object( v.target )
      if sobj and object_level_name( sobj ) == lname then
        local treasure_prob = xr_logic.pick_section_from_condlist(
          db.actor, db.actor, v.cond
        )
        if treasure_prob == "" or treasure_prob == nil then
          treasure_prob = 0
        end
        treasure_prob = tonumber( treasure_prob )
        if treasure_prob > 0 and treasure_prob < 100 then
          table.insert( avail, { k = k, prob = treasure_prob, sobj = sobj } )
          tr_sum = tr_sum + treasure_prob
        end
      end
    end
  end
  if tr_sum == 0 then return end
  local tr_w = dsh.get_next_random( script_name() .. ".rnd", tr_sum )
  for k, v in pairs( avail ) do
    tr_w = tr_w - v.prob
    if tr_w <= 0 then
      n_rank = db.actor:character_rank()
      local items = self:give_treasure( v.k, true, true )
      return v.sobj, items
    end
  end
end
