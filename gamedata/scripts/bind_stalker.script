-- -*- mode: lua; coding: windows-1251-dos -*-
-- файл из мода "Народной солянки 2009" от 14.06.
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

function init( obj )
  xr_motivator.AddToMotivator( obj )
end

function actor_init( npc )
  npc:bind_object( actor_binder( npc ) )
end


local sim = alife()


class "actor_binder" ( object_binder )
function actor_binder:__init( obj ) super( obj )
  sim = alife()
  self.bCheckStart = false
  self.weather_manager = level_weathers.WeatherManager()
  self.actor_detector  = xr_detector.actor_detector()
  self.is_saved    = false
  self.am          = ogse_signals.get_mgr()
  self.am:call( "on_load_before_all" )
  self.am:call( "on_init", obj )
  event( "actor_init" ):trigger({ object = obj })
end

function actor_binder:__finalize()
  self.am:call( "on_finalize", obj )
  event( "actor_finalize" ):trigger()
end


function actor_binder:net_spawn( data )
  db.add_actor( self.object )
  self.am:call( "on_before_spawn" )
  zamok.restore()
  level.show_indicators()
  self.bCheckStart = true
  if object_binder.net_spawn(self,data) == false then
    return false
  end
  set_extensions_flags( 15 )

  if actor_stats.add_to_ranking ~= nil then
    actor_stats.add_to_ranking( self.object:id() )
  end

  death_manager.init_drop_settings()
  amk.on_game_load( obj )
--  xr_gulag.make_restrictors_registry()
  sak.add_tail()
  braad_test.false_info()
  meceniy_work.main()
  spawn_level_changer.remove_old_teleport()
  -- kostya_level --
  spawn_teleport.spawn_teleport_exit()
  spawn_teleport.spawn_teleport_hospital()
  netpacket_pda_id = netpacket_pda_create.create_pda()
  akill.akill_start_sound()

  -------- пауза при загрузке ---------------
  if not ui_mm_opt_main.GetOption( "pause_on_load" ) then
    ui_main_menu.start()
  end
  -------------------------------------------

  self.am:subscribe({
    signal = "on_update", fun = self.check_acv_giv,
    self = self, script_name = script_name(),
  })

  self.am:subscribe({ signal = "on_inventory_open", fun = this.hide_weapon    })
  self.am:subscribe({ signal = "on_inventory_hide", fun = this.restore_weapon })
  self.am:subscribe({ signal = "on_pda_open",   fun = this.hide_weapon    })
  self.am:subscribe({ signal = "on_pda_hide",   fun = this.restore_weapon })
  self.am:subscribe({ signal = "on_talk_open",  fun = this.hide_weapon    })
  self.am:subscribe({ signal = "on_talk_hide",  fun = this.restore_weapon })
  self.am:subscribe({ signal = "on_trade_open", fun = this.hide_weapon    })
  self.am:subscribe({ signal = "on_trade_hide", fun = this.restore_weapon })

  self.am:call( "on_spawn", data )
  event( "actor_spawn" ):trigger({ data = data })
  return true
end


function actor_binder:net_destroy()
  amk.on_game_save( obj )
  set_extensions_flags( 0 )

  if actor_stats.remove_from_ranking ~= nil then
    actor_stats.remove_from_ranking( self.object:id() )
  end
  db.del_actor( self.object )

  self.object:set_callback( callback.inventory_info, nil )
  self.object:set_callback( callback.article_info, nil )
  self.object:set_callback( callback.on_item_take, nil )
  self.object:set_callback( callback.on_item_drop, nil )
  self.object:set_callback( callback.trade_sell_buy_item, nil )
  -- self.object:set_callback( callback.actor_sleep, nil )
  self.object:set_callback( callback.task_state, nil )
  -- self.object:set_callback( callback.map_location_added, nil )
  self.object:set_callback( callback.level_border_enter, nil )
  self.object:set_callback( callback.level_border_exit, nil )
  self.object:set_callback( callback.take_item_from_box, nil )
  self.object:set_callback( callback.use_object, nil )
  self.object:set_callback( callback_ex.on_key_press, nil )
  self.object:set_callback( callback_ex.on_key_release, nil )
  self.object:set_callback( callback_ex.on_key_hold, nil )
  self.object:set_callback( callback_ex.on_mouse_wheel, nil )
  self.object:set_callback( callback_ex.on_mouse_move, nil )
  self.object:set_callback( callback_ex.on_belt, nil )
  self.object:set_callback( callback_ex.on_ruck, nil )
  self.object:set_callback( callback_ex.on_slot, nil )
  self.object:set_callback( callback_ex.on_select_item, nil )
  self.object:set_callback( callback_ex.on_hud_animation_end, nil )
  self.object:set_callback( callback.hit, nil )
  self.object:set_callback( callback_ex.on_goodwill_change, nil )
  -- self.object:set_callback( callback_ex.on_release_npc, nil )
  self.object:set_callback( callback.death, nil )
  self.object:set_callback( callback_ex.entity_alive_before_hit, nil )
  self.object:set_callback( callback_ex.on_before_use_item, nil )
  self.object:set_callback( callback_ex.on_after_save, nil )
  self.object:set_callback( callback_ex.on_create_cell_item, nil )

  if sr_psy_antenna.psy_antenna then
    sr_psy_antenna.psy_antenna:destroy()
    sr_psy_antenna.psy_antenna = false
  end

  xr_sound.stop_all_sound_object()

  self.am:call( "on_destroy" )
  event( "actor_destroy" ):trigger()

  object_binder.net_destroy( self )
end


function actor_binder:reinit()
  object_binder.reinit( self )
  
  local npc_id = self.object:id()
  db.storage[ npc_id ] = {}
  self.st = db.storage[npc_id]
  self.st.pstor = nil

  self.object:set_callback( callback.inventory_info, self.info_callback, self )
  self.object:set_callback( callback.article_info, self.article_callback, self )
  self.object:set_callback( callback.on_item_take, self.on_item_take, self )
  self.object:set_callback( callback.on_item_drop, self.on_item_drop, self )
  self.object:set_callback( callback.trade_sell_buy_item, self.on_trade, self )
  -- self.object:set_callback( callback.actor_sleep, self.sleep_callback, self )
  self.object:set_callback( callback.task_state, self.task_callback, self )
  -- self.object:set_callback( callback.map_location_added, self.map_location_added_callback, self )
  self.object:set_callback( callback.level_border_enter, self.level_border_enter, self )
  self.object:set_callback( callback.level_border_exit, self.level_border_exit, self )
  self.object:set_callback( callback.take_item_from_box, self.take_item_from_box, self )
  self.object:set_callback( callback.use_object, self.on_use_object, self )
  self.object:set_callback( callback.hit, self.hit_callback, self )
  self.object:set_callback( callback.death, self.death_callback, self )

  -- нажатие клавиши
  self.object:set_callback( callback_ex.on_key_press, self.on_key, self )
  -- отпускание клавиши
  self.object:set_callback( callback_ex.on_key_release, self.on_key_free, self )
  -- удержание клавиши
  self.object:set_callback( callback_ex.on_key_hold, self.on_key_hold, self )
  -- вращение колесика мыши
  self.object:set_callback( callback_ex.on_mouse_wheel, self.on_wheel_rotation, self )
  -- движение мыши
  self.object:set_callback( callback_ex.on_mouse_move, self.on_mouse_move, self )
  -- перемещение предмета на пояс
  self.object:set_callback( callback_ex.on_belt, self.item_to_belt, self )
  -- перемещение предмета в рюкзак
  self.object:set_callback( callback_ex.on_ruck, self.item_to_backpack, self )
  -- перемещение предмета в слот
  self.object:set_callback( callback_ex.on_slot, self.item_to_slot, self )
  self.object:set_callback( callback_ex.on_select_item, self.on_select_item, self )
  -- вызывается в конце проигрывания анимации худа (только если используем
  -- play_hud_animation)
  self.object:set_callback( callback_ex.on_hud_animation_end, self.hud_animation_end, self )
  -- изменение отношений
  self.object:set_callback( callback_ex.on_goodwill_change, self.on_goodwill_change, self )
  -- удаление серверного объекта непися или монстра
  -- self.object:set_callback( callback_ex.on_release_npc, self.on_release_npc, self )
  self.object:set_callback( callback_ex.entity_alive_before_hit, self.before_hit_callback, self )
  self.object:set_callback( callback_ex.on_before_use_item, self.before_use, self )
  self.object:set_callback( callback_ex.on_after_save, self.after_save, self )
  self.object:set_callback( callback_ex.on_create_cell_item, self.create_cell_item, self )

  self.am:call( "on_reinit" )
  event( "actor_reinit" ):trigger()
end


function actor_binder:hud_animation_end( a1, blend_addr )
  local addr  = sum_args_ex( blend_addr, 56 )
  local value = db.actor:get_memory_int( "", addr )
end


function actor_binder:on_goodwill_change( from, to )
  self.am:call( "on_goodwill_change", from, to )
end


function actor_binder:on_release_npc( npc_id )
  self.am:call( "on_release_npc", npc_id )
end


function actor_binder:death_callback( victim, who )
  if victim:id() == db.actor:id() then
    archievements.on_actor_death( who )
  end
	
  -- Правка неотключения пения контролера после смерти гг
  if kostya_dialog.kill_online_kontroller() then
    news_manager.send_tip(
      db.actor,
     "Если во время смерти ГГ звучало \"пение\" контролера, то дождитесь его завершения прежде, чем загрузить сохранение, иначе придется полностью перезапускать игру.",
     nil, "nano", 30000
    )
  end
end


function actor_binder:take_item_from_box( box, item )
  -- если калбек на взятие предмета из тайника поставить сюда, а не в
  -- on_item_take, то калбек сработает только один раз и не будет вызываться
  -- каждый раз при лоаде, поэтому поршнем его отсекать не нужно
  fly.returner_clear_pos( item )
  braad_test.mina_band2( item )
	
  -- подъем рюкзаков
  if box:is_inv_box_empty() then
    if transparent_treasure.IsTaken( box:section() ) then 
      level.start_stop_menu( level.main_input_receiver(), true )
      -- здесь можно прописывать калбеки взятия на проверку по секции тайника,
      -- чтобы не придумывать уникальные предметы
      archievements.check_treasure( box )
      alife():create(
        "treasure_item",
        box:position(),
        db.actor:level_vertex_id(), db.actor:game_vertex_id(), 0
      )
      alife():release( alife():object( box:id() ) )
    end
    if box:section() ~= "m_inventory_box" then
      archievements.acv_count_event( "acv_sled", 300, "Следопыт" )
    end
  end

  self.am:call( "on_take_from_box", box, item, sim:object( item:id() ) )
  event( "actor_take_item_from_box" ):trigger({ from = box, what = item })

  amk.on_item_take_from_box( box, item )
end


function actor_binder:level_border_enter( npc, info_id )
  self.am:call( "on_level_border_enter", npc, info_id )
  event( "actor_level_border_enter" ):trigger({ who = npc, info = info_id })
end


function actor_binder:level_border_exit( npc, info_id )
  self.am:call( "on_level_border_exit", npc, info_id )
  event( "actor_level_border_exit" ):trigger({ who = npc, info = info_id })
end


local info2call = {
  ui_pda                   = "on_pda_open",
  ui_pda_hide              = "on_pda_hide",
  ui_pda_contacts          = "on_pda_contacts_open",
  ui_pda_contacts_hide     = "on_pda_contacts_hide",
  ui_pda_map_local         = "on_pda_map_local",
  ui_pda_map_global        = "on_pda_map_global",
  ui_pda_news              = "on_pda_news_open",
  ui_pda_news_hide         = "on_pda_news_hide",
  ui_pda_jobs_failed       = "on_pda_jobs_failed",
  ui_pda_jobs_accomplished = "on_pda_jobs_accomplished",
  ui_pda_jobs_current      = "on_pda_jobs_current",
  ui_pda_jobs              = "on_pda_jobs_open",
  ui_pda_jobs_hide         = "on_pda_jobs_hide",
  ui_pda_diary             = "on_pda_diary_open",
  ui_pda_diary_hide        = "on_pda_diary_hide",
  ui_pda_encyclopedia      = "on_pda_encyclopedia_open",
  ui_pda_encyclopedia_hide = "on_pda_encyclopedia_hide",
  ui_pda_actor_info        = "on_pda_actor_info",
  ui_pda_ranking           = "on_pda_ranking",
  ui_pda_events            = "on_pda_events",
  ui_inventory             = "on_inventory_open",
  ui_inventory_hide        = "on_inventory_hide",
  ui_talk                  = "on_talk_open",
  ui_talk_hide             = "on_talk_hide",
  ui_trade                 = "on_trade_open",
  ui_trade_hide            = "on_trade_hide",
  ui_car_body              = "on_body_open",
  ui_car_body_hide         = "on_body_hide",
}

function actor_binder:info_callback( npc, info_id )
  --' Сюжет
  level_tasks.proceed( self.object )
  -- Отметки на карте
  archievements.on_info( info_id )
  level_tasks.process_info_portion( info_id )
  
  --AMK UTILS--
  amk.on_info( npc,info_id )
  amk_utils.actor_info( npc, info_id )
  --AMK UTILS--
  if npc:id() == db.actor:id() then
    meceniy_spawn.respawn( info_id )
  end

  self.am:call( "on_info", npc, info_id )
  event( "actor_info" ):trigger({ who = npc, info = info_id })
  local sc = info2call[ info_id ]
  if sc then
    self.am:call( sc, npc )
    event( sc ):trigger({ who = npc })
  end
end


function actor_binder:on_trade( item, sell_bye, money )
  if sell_bye == true then
    game_stats.money_trade_update( money )
  else       
    if isMagazinedWeapon( item ) then
      item:unload_magazine()
    end
    archievements.on_receive_count_item( item )
    game_stats.money_trade_update( -money )
  end

  self.am:call( "on_trade", item, sell_bye, money )
  event( "actor_trade"):trigger({
    what = item, money = money, item_is_sold = sell_bye
  })
  db.traded = true
end


function actor_binder:article_callback( npc, group, name, article_type )
  if device().precache_frame >1 then return end
  
  if group == "Diary" then
    news_manager.send_encyclopedy( "diary", group )
  else
    news_manager.send_encyclopedy( "encyclopedy", group )
  end
  
  --AMK UTILS--
  amk.on_info( npc,info_id )
  amk_utils.actor_article( npc, group, name )
  --AMK UTILS--
  
  self.am:call( "on_article", npc, group, name, article_type )
  event( "actor_article" ):trigger({
    who = npc, article_group = group, article_name = name,
    article_type = article_type
  })
end


function actor_binder:on_item_take( obj )
  level_tasks.proceed( self.object )
  amk_utils.actor_item_take( obj )
  if obj:clsid() == clsid.wpn_ammo then 
    dunin_ammo.on_take( obj )
  end 
  sak.check_used_item( obj )

  if device().precache_frame < 1 then
    local s = get_string( obj:section(), script_name() .. ".on_take_call" )
    if s then
      local f, err = loadstring( "return " .. s .. "( ... )" )
      ASSERT( f, err )
      f( obj )
    end
    amk.on_item_take( obj )
    braad_test.checking_use_item( obj )
    babah.on_item_take( obj )
    monster_parts.on_part_take( obj )
    fly.returner_clear_pos( obj )
    if
      obj:is_weapon_magazined() and self.object:is_talking()
      and not protected_items.not_unloaded_weapon( obj:section() )
    then
      obj:unload_magazine()
    end
  end
	
  local sobj = alife():object( obj:id() )
  if sobj then -- такое бывает, если до этого объект был удалён в on_ruck
    self.am:call( "on_take", obj, sobj )
    event( "actor_item_take" ):trigger({ what = obj })
  end
end


function actor_binder:on_item_drop( obj )
  level_tasks.proceed( self.object )
  --AMK UTILS--
  amk.on_item_drop( obj )
  amk_utils.actor_item_drop( obj )
  --AMK UTILS--
  sak.check_droped_item( obj )
  braad_test.drop_actor( obj )
  braad_test.drop_lim( obj )
  kostya_dialog.peshera_drink( obj )

  self.am:call( "on_drop_before_all", obj )
  local sobj = sim:object( obj:id() )
  if sobj then
    self.am:call( "on_drop", obj, sobj )
    event( "actor_item_drop" ):trigger({ what = obj })
  end
end


function actor_binder:before_use( item )
  self.am:call( "on_actor_before_use", item, sim:object( item:id() ) )
end


function actor_binder:before_hit_callback( p_s_hit, p_ignore_flags )
  self.last_hit_data = read_hit_data( p_s_hit )
  self.am:call(
    "on_actor_before_hit", self.last_hit_data, p_s_hit, p_ignore_flags
  )
end


function actor_binder:task_callback( _task, _objective, _state )
  task_manager.task_callback( _task:get_id(), _objective:get_idx(), _state )
  if _objective:get_idx() == 0 then
    if _state == task.fail then
      if db.actor then
        db.actor:give_info_portion( "acv_task_fail" )
      end
      news_manager.send_task( db.actor, "fail", _task, _objective )
    elseif _state == task.completed then
      task_manager.reward_by_task( _task )
      news_manager.send_task( db.actor, "complete", _task, _objective )
    else
      news_manager.send_task( db.actor, "new", _task, _objective )
    end
  else
    if _task:get_objective( 0 ):get_state() == task.in_progress then
      news_manager.send_task( db.actor, "update", _task, _objective )
    end
  end
  
  --AMK UTILS--
  amk_utils.actor_task( _task, _objective, _state )
  --AMK UTILS--
  
  self.am:call( "on_task", _task, _objective, _state )
  event( "actor_task" ):trigger({
    task = _task, objective = _objective, state = _state
  })
end


function actor_binder:map_location_added_callback( spot_type_str, object_id )
  if ( false == app_ready() ) or device().precache_frame > 1 then return end
  self.am:call( "on_add_map_location", spot_type_str, object_id )
  event( "actor_add_map_location" ):trigger({
    spot_type = spot_type_str, object_id = object_id
  })
end


local update_was_never_called = true
scopeUsed = false

function actor_binder:update( delta )
  if update_was_never_called then
    self.am:call( "on_before_first_update" )
  end
  self.am:call( "on_before_update", delta )

  local time       = time_global()
  amk.oau_reason   = "actor_binder:update"
  amk.oau_watchdog = 2001
  object_binder.update( self, delta )

  amk.oau_watchdog = 188
  if self.bCheckStart then
    db.money = self.object:money()

    if
      ( not has_alife_info( "storyline_actor_start" ) )
      and level.name() == "l01_escape"
    then
      self.am:call( "on_storyline_start" )
      self.object:give_info_portion( "storyline_actor_start" )
      _G.g_start_avi = true
    end

    if
      ( not has_alife_info( "encyclopedy" ) )
      and has_alife_info( "arhara_shaxter_start" )
    then
      self.object:give_info_portion( "encyclopedy" )
    end

    if not has_alife_info( "global_dialogs" ) then
      self.object:give_info_portion( "global_dialogs" )
    end

    if not has_alife_info( "level_changer_icons" ) then
      self.object:give_info_portion( "level_changer_icons" )
    end

    if update_was_never_called then
      for k, v in pairs( xr_companion.companions ) do
        if xr_companion.companions[ k ] == "companion" then
          xr_companion.check_teleport( k )
        end
      end
    end

    level_tasks.add_lchanger_location()
    all_spawn_fix.respawn_allspawn()
    ui_mm_opt_add.send_bad_objects_info()
    ui_load_dialog.saved_games_limit_show_error()
    archievements.acv_death()

    if
      has_alife_info( "sar_monolith_destroy" )
      and not has_alife_info( "sar2_monolith_miracle" )
    then
      db.actor:give_info_portion( "sar2_monolith_miracle" )
    end

    if not has_alife_info( "acv_giv" ) then
      db.actor.no_load_time = amk.game_minutes() + 9 * 60
    end

    ASSERT(
      amk.start_timer_no_save(),
      "Этим сохранением пользоваться нельзя. Удалите его."
    )
	
    ui_mm_opt_add.del_bad_objects()
    self.bCheckStart = nil    
  end 
  
  amk.oau_watchdog = 0
  amk.oau_reason   = ""    
  
  if update_was_never_called then
    self.am:call( "on_first_update" )
    update_was_never_called = false
  end
  self.am:call( "on_update", delta )
  -- event( "actor_update" ):trigger({ delta = delta })
  
  -- Обновление упаковщика патронов -- должно быть предпоследним на апе актора!
  dunin_ammo.on_update()	
  -- Отложенное удаление патронов -- должно быть последним на апе актора!
  death_manager.release_deferred_ammo()
end


function actor_binder:show_hud_save_warning( crit, timeout, low, argb )
  if self.hud_save_warning_t then
    if low then
      return
    else
      self.hud_save_warning_t:stop()
    end
  end
  if not argb then
    argb = { 255, 155, 0, 0 }
  end
  self.hud_save_warning_t = dsh.timeout( 0, function()
    if not get_hud():GetCustomStatic( "hud_save_warning" ) then
      get_hud():AddCustomStatic( "hud_save_warning" )
    end
    local wnd = get_hud():GetCustomStatic( "hud_save_warning" ):wnd()
    wnd:SetTextColor( unpack( argb ) )
    if crit == 1 then
      wnd:SetTextST( game.translate_string( "amk_warn_trans" ) )
    elseif crit == 2 then
      wnd:SetTextST( game.translate_string( "amk_warn_trans_critical" ) )
    else
      -- wnd:SetTextST( game.translate_string( "amk_warn_attention" ) )
      wnd:SetTextST( game.translate_string( crit ) )
    end
    self.hud_save_warning_t = dsh.timeout( timeout, function()
      if get_hud():GetCustomStatic( "hud_save_warning" ) then
        get_hud():RemoveCustomStatic( "hud_save_warning" )
      end
      self.hud_save_warning_t = nil
    end )
  end )
end


function actor_binder:check_acv_giv()
  self.am:reschedule( 10000 )
  if update_was_never_called then return end -- пропускаем первый апдейт
  if
    db.actor.no_load_time
    and db.actor.no_load_time < amk.game_minutes()
  then
    db.actor:give_info_portion( "acv_giv" )
    db.actor.no_load_time = nil
  end
  if not has_alife_info("acv_stay1") and amk.game_days() > 182 then
    db.actor:give_info_portion( "acv_stay1" )
  elseif not has_alife_info( "acv_stay2" ) and amk.game_days() > 365 then
    db.actor:give_info_portion("acv_stay2")
  end
end


function actor_binder:on_key( key )
  self.am:call( "on_key_down", key, dik_to_bind( key ) )
  event( "key_down" ):trigger({ key = key, bind = dik_to_bind( key ) })
end


function actor_binder:on_key_free( key )
  self.am:call( "on_key_up", key, dik_to_bind( key ) )
  event( "key_up" ):trigger({ key = key, bind = dik_to_bind( key ) })
end


function actor_binder:on_key_hold( key )
  self.am:call( "on_key_hold", key, dik_to_bind( key ) )
  event( "key_hold" ):trigger({ key = key, bind = dik_to_bind( key ) })
end


function actor_binder:on_wheel_rotation( vol )
  self.am:call( "on_wheel", vol - 100000 )
  event( "mouse_wheel" ):trigger({ val = vol - 100000 })
end


function actor_binder:on_mouse_move( velx, vely )
  self.am:call( "on_mouse_move", velx - 100000, vely - 100000 )
  event( "mouse_move" ):trigger({ x = velx - 100000, y = vely - 100000 })
end


function actor_binder:item_to_belt( obj )
  local sobj = sim:object( obj:id() )
  if sobj then
    self.am:call( "on_item_to_belt", obj, sobj )
    event( "actor_item_to_belt" ):trigger({ what = obj })
  end
end


function actor_binder:item_to_backpack( obj )
  local sobj = sim:object( obj:id() )
  if sobj then
  -- такое бывает, когда спавним в инвентарь предмет, а потом его тут же
  -- удаляем ещё выхода в онлайн
    self.am:call( "on_item_to_ruck", obj, sobj )
    event( "actor_item_to_ruck" ):trigger({ what = obj })
  end
end


function actor_binder:item_to_slot( obj )
  local sobj = sim:object( obj:id() )
  if sobj then
    self.am:call( "on_item_to_slot", obj, sobj )
    event( "actor_item_to_slot" ):trigger({ what = obj })
  end
end


function actor_binder:on_select_item( obj )
  local sobj = sim:object( obj:id() )
  if sobj then
    self.am:call( "on_select_item", obj, sobj )
  end
end


function actor_binder:hit_callback( obj, amount, local_direction, who, bone_index )
  self.am:call( "on_hit", obj, amount, local_direction, who, bone_index )
  event( "actor_hit" ):trigger({
    victim = obj, amount = amount, dir = local_direction, who = who,
    bone = bone_index
  })
end


function actor_binder:save( packet )
  if ogse_st_mgr.timer_exists( "amk.no_save" ) and not db.debug then
    abort( "Сохранение сделано слишком быстро после загрузки. Из-за этого очень вероятно, что созданное сохранение, а также текущее игровое состояние будет повреждено. Поэтому немедленно удалите только что созданное сохранение, затем полностью перезапустите игру." )
    dsh.delay( 3000, kostya_dialog.zonedocs_gg_kill )
  end

  -- удаление запущенных варок перед сейвом
  amk.remove_timer( "af_transform_universal" )
  
  if level.get_game_difficulty() == 0 then
    db.actor:give_info_portion( "acv_real_fail" )
  end
  
  if not has_alife_info("teleport_started") and utils.level_changing() then
    archievements.acv_count_event( "acv_skit", 300, "Скиталец" )
  end

  if rx_ai then rx_ai.actor_save( packet ) end

  local pk1 = fake_net_packet.fake_net_packet()
  self:save_old( pk1 )
  log1( "~~Actor netpacket size " .. pk1:w_tell() )
  get_console():execute( "flush" )
  if pk1:w_tell() > 7500 then
    task_manager.cleanup_actor()
  end	
  if pk1:w_tell() > 7700 then
    task_manager.cleanup_actor()
  end

  pk1 = fake_net_packet.fake_net_packet()
  self:save_old( pk1 )
  amk.mylog( "Packet size is " .. pk1:w_tell() )
  if pk1:w_tell() > 7500 then
    self:show_hud_save_warning( 1, 60000 )
    amk.emergency_cleanup()
    self:save_old( packet )
    amk.mylog( "Actor packet size is " .. packet:w_tell() .. "!" )
    amk.send_tip(
      "Actor packet size critical = 2 > 7500 ",
      "Размер нетпакета ГГ критический:" .. pk1:w_tell(), 0, 15, "gen_info"
    )
    amk.emergency_restore()
  else
    self:save_old( packet )
  end
  self.am:call( "on_save", packet )
  event( "actor_save" ):trigger({ packet = packet })
  self.am:call( "on_save_after_all" )
  self.is_saved = true
end


function actor_binder:save_old( packet )
  local save_treasure_manager = true
  object_binder.save( self, packet )

  --' Сохраняем уровень сложности
  if save_treasure_manager == true then
    packet:w_u8( level.get_game_difficulty() + 128 )
  else
    packet:w_u8( level.get_game_difficulty() )
  end

  --' Сохраняем данные об отключенном вводе
  packet:w_bool( false )

  xr_logic.pstor_save_all( self.object, packet )
  self.weather_manager:save( packet )
  sr_psy_antenna.save( packet )
  if save_treasure_manager == true then
    treasure_manager.save( packet )
  end                                  
  task_manager.save( packet )
  self.actor_detector:save( packet )
end


function actor_binder:load( reader )
  object_binder.load( self, reader )

  --' Загружаем уровень сложности
  local game_difficulty = reader:r_u8()
  local load_treasure_manager = false      
  if game_difficulty >= 128 then           
    game_difficulty = game_difficulty - 128
    load_treasure_manager = true           
  end                                      

  local game_difficulty_by_num = {
    [0] = "gd_novice",
    [1] = "gd_stalker",
    [2] = "gd_veteran",
    [3] = "gd_master"
  }
  get_console():execute(
    "g_game_difficulty " .. game_difficulty_by_num[ game_difficulty ]
  )

  if reader:r_eof() then
    abort( "Это сохранение необратимо повреждено - удалите его, и переиграйте с более раннего сохранения. Продолжать игру на этом сохранении категорически запрещено!" )
    string.format( "%s" )
  end

  local stored_input_time = reader:r_u8()
  -- оставлено для совместимости
  if stored_input_time == true then
    utils.r_CTime( reader )
  end

  xr_logic.pstor_load_all( self.object, reader )
  self.weather_manager:load( reader )
  sr_psy_antenna.load( reader )
  if load_treasure_manager == true then
    treasure_manager.load( reader )
  end                                  
  task_manager.load( reader )
  self.actor_detector:load( reader )

  self.am:call( "on_load", reader )
  event( "actor_load" ):trigger({ packet = reader })
  
  if xr_logic.pstor_retrieve( self.object, "emerg", false ) then
    -- нельзя использовать amk.load_varible(), так как db.actor ещё не
    -- определён
    self:show_hud_save_warning( 2, 60000 )
  end
end


function actor_binder:on_use_object( obj )
  archievements.on_use_item( obj )
  buusty_dialog.use_money( obj )
  if obj then
    local sobj = sim:object( obj:id() )
    if sobj then
      self.am:call( "on_use", obj, sobj )
      event( "actor_use_inventory_item" ):trigger({ what = obj })
    end
  end
end


function actor_binder:after_save()
  self.am:call( "on_after_save" )
end


function actor_binder:create_cell_item( obj )
  self.am:call( "on_create_cell_item", obj )
end


-- Weapon functions
local restore_wpn_t, weapon_hide

function hide_weapon()
  weapon_hide = true
  if restore_wpn_t then return end
  db.actor:hide_weapon()
  restore_wpn_t = dsh.wait_condition(
    function()
      local outfit = db.actor:get_current_outfit()
      return not (
        weapon_hide
        or db.actor:is_talking()
        or db.eat
        or ( outfit and outfit:section() == "meceniy_outfit_new" )
      )
    end,
    function()
      db.actor:restore_weapon()
      weapon_hide   = false
      restore_wpn_t = nil
    end,
    function()
      ogse_signals.get_mgr():reschedule( 200 )
    end
  )
end

function restore_weapon()
   weapon_hide = false
end


function has_traded()
	if db.traded then
		if db.actor:is_talking() then
			db.actor:stop_talk()
		end
		db.traded = nil
	end
end
