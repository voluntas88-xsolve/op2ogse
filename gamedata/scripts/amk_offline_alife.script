-- -*- mode: lua; coding: windows-1251-dos -*-
-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

off_npcs = {}
items    = {}
always_keep_item = {}

-- Как часто делать апдейты, реальные минуты
local iFreq       = 0 --12
-- Как часто генерить события в оффлайн (реальные секунды)
local alife_freq  = 48

local maps = {
  "atp_for_test22",
  "aver",
  "dead_city",
  "generators",
  "hospital",
  "jupiter",
  -- "jupiter_underground",
  -- "labx8",
  "l01_escape",
  "l02_garbage",
  "l03_agroprom",
  "l03u_agr_underground",
  "l04_darkvalley",
  -- "l04u_labx18",
  "l05_bar",
  "l06_rostok",
  "l07_military",
  "l08_yantar",
  -- "l08u_brainlab",
  "l10_radar",
  -- "l10u_bunker",
  "l11_pripyat",
  -- "l12_stancia",
  -- "l12_stancia_2",
  -- "l12u_control_monolith",
  -- "l12u_sarcofag",
  "limansk",
  "lost_village",
  "marsh",
  "puzir",
  "pripyat",
  "red_forest",
  "warlab",
  "zaton",
}

protected = {
  names     = {}, -- имена объектов (стоит добавлять только уникальные имена!)
  ids       = {}, -- ID объектов
  story_ids = {   -- story ID объектов
    5008,
    5013,
    5014,
    5041,
    5065,
    5084,
    5104,
    5205,
    5222,
    5226,
    5237,
    5238,
    5243,
    5244,
    5245,
    5246,
    5247,
    5248,
    5249,
    5250,
    5254,
    5255,
    5408,
    5413,
    5428,
    5433,
    5434,
    5444,
    5446,
    5470,
    5471,
    5472,
    5473,
    5474,
    573,
  },
  sections = {    -- секции объектов
    "volna_shron",
    "taynik_kuznec7",
    "dyak_mines_box",
    "radiodetail_box2",
    "radiodetail_box4",
    "keis_key_box",
    "computer_flash",
    "notebook_flash",
    "disk_flash",
    "pda_flash",
    "taynik_podarok",
  },
}

-- радиус "обзора"
local look_radius        = 50
-- Вещи дешевле продает торговцам
local sell_limit         = 3000
local rate_art_found     = 100
local to_actor           = 150
local look_radius_box    = 20

local friends_comm = {
  [ "dolg"    ] = true,
  [ "ecolog"  ] = true,
  [ "freedom" ] = true,
  [ "green"   ] = true,
  [ "nebo"    ] = true,
  [ "stalker" ] = true,
}

npc_can_trade_anyway = {
  [ "esc_kostya"         ] = true,
  [ "val_escort_captive" ] = true,
}


function is_npc_can_trade( sobj )
  return IsStalker( sobj )
    and sobj:alive() and sobj:health() > 0
    and sobj:community() ~= "zombied"
    and (
      sobj.m_story_id == 4294967296
      or npc_can_trade_anyway[ sobj:name() ]
    )
    and ( not xr_companion.is_companion( sobj.id ) )
    and ( not protected_items.is_no_offline_alife_npc( sobj:section_name() ) )
end


function schedule_update()
  if iFreq == 0 then return end
  dsh.timeout( iFreq * 60 * 1000, function()
    off_npcs = {}
    items    = {}
    offline_update_timer():start( true )
  end )
end


class "offline_update_timer" ( ogse_qt.quick_timer )
function offline_update_timer:__init() super()
  self.cur_id = 1
end

function offline_update_timer:condition()
  return self.cur_id == 65535
end

function offline_update_timer:action()
  schedule_update()
end

function offline_update_timer:update()
  local sobj = alife():object( self.cur_id )
  if sobj then
    add_fresh_meat( sobj )
  end
  self.cur_id = self.cur_id + 1
end


function add_fresh_meat( obj )
  if
    obj and obj.m_game_vertex_id
    and game_graph():valid_vertex_id( obj.m_game_vertex_id )
    and db.actor and (
      db.actor:id() ~= obj.id
      and obj.parent_id ~= db.actor:id()
    )
    and ( not always_keep_item[ obj:section_name() ] )
    and ( not protected_items.actor_items_keep( obj:section_name() ) )
    and ( not protected_items.is_grab_body_item_keep( obj:section_name() ) )
    and ( not protected_items.is_no_offline_alife_npc( obj:section_name() ) )
    and ( not get_bool( obj:section_name(), "quest_item", false ) )
    and ( not get_bool( obj:section_name(), "watcher_act.bad_item", false ) )
  then
    local map = object_level_name( obj )
    if not off_npcs[ map ] then
      off_npcs[ map ] = {
        artefacts = {},
        inv_boxes = {},
        monsters  = {},
        stalkers  = {},
        weapons   = {},
      }
    end
    if is_npc_can_trade( obj ) then
      table.insert(
        off_npcs[ map ].stalkers, { id = obj.id, name = obj:name() }
      )
    elseif dsh.is_artefact( obj:section_name() ) and obj.parent_id == 65535 then
      table.insert(
        off_npcs[ map ].artefacts, { id = obj.id, name = obj:name() }
      )
    elseif
      (
        obj:clsid() == clsid.inventory_box
        and not box_is_protected( obj )
      )
      or (
        obj:section_name() == "dsh_treasure_item"
        and not protected.ids[ obj.id ]
      )
    then
      table.insert(
        off_npcs[ map ].inv_boxes, { id = obj.id, name = obj:name() }
      )
    elseif obj.parent_id ~= 65535 and obj.m_story_id == 4294967296 then
      local zz = alife():object( obj.parent_id )
      if zz then
        if not protected.ids[ obj.parent_id ] then
          if not items[ obj.parent_id ] then items[ obj.parent_id ] = {} end
          table.insert(
            items[ obj.parent_id ],
            {
              id    = obj.id,
              lname = map,
              name  = obj:name(),
            }
          )
        end
        -- Idler++-- корректируем хабар в помеченных тайниках
        gps_habar.insert_item( obj.parent_id, obj )
      end
    end
  end
end


function update_npc_tables()
  items    = {}
  off_npcs = {}
  for a = 1, 65534 do
    local sobj = alife():object( a )
    if sobj then
      add_fresh_meat( sobj )
    end
  end
  schedule_update()
  dsh.timeout( math.random( alife_freq ) * 1000, function()
    offline_alife_timer():start()
  end )
end


local weapon_repair_allowed = false
function update_trade()
  if
    ogse_st_mgr.timer_exists(
      script_name() .. ".weapon_repair.forbidden"
    )
  then
    weapon_repair_allowed = false
  else
    weapon_repair_allowed = true
  end
  local pt  = profile_timer()
  pt:start()
  for id, sobj in pairs( se_stalker.stalkers ) do
    process_trade( sobj )
  end
  pt:stop()
  log2( "[%s]: trade updated: %s", script_name(), pt:time() )
  if weapon_repair_allowed then
    dsh.start_gtimerDHMS(
      script_name() .. ".weapon_repair.forbidden",
      0, math.random( 20, 24 ), 0, 0,
      script_name() .. ".process_weapon_repair_allowed"
    )
    weapon_repair_allowed = false
  end
end


function update_tables( level )
  cleanup_this_level_items( level )
  local ggraph = game_graph()
  local sim    = alife()
  for a = 1, 65534 do
    local obj = sim:object( a )
    if obj then
      if
        ggraph:valid_vertex_id( obj.m_game_vertex_id )
        and object_level_name( obj ) == level
      then
        add_fresh_meat( obj )
      elseif obj.parent_id then
        local p_obj = sim:object( obj.parent_id )
        if
          p_obj
          and ggraph:valid_vertex_id( p_obj.m_game_vertex_id )
          and object_level_name( p_obj ) == level
        then
          add_fresh_meat( obj )
        end
      end
    end
  end
end


function cleanup_this_level_items( lname )
  off_npcs[ lname ] = {
    monsters = {}, stalkers = {}, weapons = {}, artefacts = {}, inv_boxes = {}
  }
  local remove = {}
  for k, v in pairs( items ) do
    if table.getn( v ) > 0 then
      if v[ 1 ].lname == lname then
        remove[ k ] = true
      end
    else
      remove[ k ] = true
    end
  end
  for k, v in pairs( remove ) do
    items[ k ] = nil
  end
end


class "offline_alife_timer" ( ogse_qt.quick_timer )
function offline_alife_timer:__init() super()
  self.lname    = maps[ math.random( table.getn( maps ) ) ]
  self.stalkers = {}
  if off_npcs[ self.lname ] then
    for _, v in ipairs( off_npcs[ self.lname ].stalkers ) do
      table.insert( self.stalkers, v )
    end
    if table.getn( self.stalkers ) > 1 then
      dsh.shuffle( self.stalkers )
    end
  end
end

function offline_alife_timer:condition()
  return table.getn( self.stalkers ) == 0
end

function offline_alife_timer:action()
  dsh.timeout( alife_freq * 1000, function()
    offline_alife_timer():start()
  end )
end

function offline_alife_timer:update()
  if table.getn( self.stalkers ) == 0 then return end
  local st     = table.remove( self.stalkers )
  local victim = alife():object( st.id )
  if
    victim and victim:name() == st.name
    and object_level_name( victim ) == self.lname
    and ( not victim.online ) and victim:alive()
    and victim:can_be_spawned()
  then
    local vdata = collect_info( victim, self.lname )
    if table.getn( vdata.artefacts ) > 0 then
      -- есть арты
      on_artifacts_found( victim, vdata )
    end
    if table.getn( vdata.inv_boxes ) > 0 then
      -- есть контейнеры. Надо обыскать.
      --on_inv_boxes_found( victim, vdata )
    end
  end
end


--собираем инфу о неписе
function collect_info( victim, map )
  local vdata = {}
  vdata.rank      = victim:rank()
  vdata.health    = victim:health()
  vdata.community = victim:community()

  --составляем список артов в зоне "видимости"
  vdata.artefacts = {}
  if off_npcs[ map ].artefacts then
    for _, v in ipairs( off_npcs[ map ].artefacts ) do
      local artefact = alife():object( v.id )
      if
        artefact and object_level_name( artefact ) == map
        and artefact.can_switch_online and artefact:can_switch_online()
        and artefact:name() == v.name
        and artefact.parent_id == 65535
        and victim.position:distance_to( artefact.position ) < look_radius
        and sobj_is_far( artefact, to_actor )
      then
        local zdist = victim.position:distance_to( artefact.position ) / look_radius
        if math.random() > zdist then
          table.insert(
            vdata.artefacts, { id = artefact.id, name = artefact:name() }
          )
        end
      end
    end
  end

  --составляем список контейнеров в зоне "видимости"
  vdata.inv_boxes = {}
  if off_npcs[ map ].inv_boxes then
    for _, v in ipairs( off_npcs[ map ].inv_boxes ) do
      local inv_box = alife():object( v.id )
      if
        inv_box
        and inv_box.can_switch_online and inv_box:can_switch_online()
        and inv_box:name() == v.name
        and inv_box.parent_id == 65535
        and victim.position:distance_to( inv_box.position ) < look_radius_box
        and sobj_is_far( inv_box, to_actor )
        and not treasure_manager.is_active( inv_box )
      then
        local zdist = victim.position:distance_to( inv_box.position ) / look_radius_box
        if math.random() > zdist then
          table.insert(
            vdata.inv_boxes, { id = inv_box.id, name = inv_box:name() }
          )
        end
      end
    end
  end

  return vdata
end


-- Моя прелесссть
function on_artifacts_found( victim, vdata )
  for _, v_obj in ipairs( vdata.artefacts ) do
    local object = alife():object( v_obj.id )
    if object then
      local obj = pick_item( victim, object )
      victim:set_rank( victim:rank() + rate_art_found )
    end
  end
end


-- О, нычка - это гуд.  Idler ++ проверим, а сможет ли непись долезть
-- до тайника.  если есть аномалии в радиусе 20м, меньше шансов или
-- если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail( victim, box )
  -- отсекаем сюжетные тайники
  if
    transparent_treasure.IsTaken( box:section_name(), box:name() )
    and box:section_name() ~= "m_inventory_box"
  then
    return false
  end
  local n_rnd = math.random( 3, 10 )
  if math.abs( box.position.y - victim.position.y ) > n_rnd then
    return false
  end
  if object_level_name( box ) == level.name() then
    local anom_list = amk_anoms.get_anomaly_list_for_pos( box.position, 20 )
    local n_anoms   = table.getn( anom_list )
    local n_rnd     = math.random( 100 )
    -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При
    -- 5 - точно до ящика не доберется
    if n_rnd < n_anoms * 20 then return false end
  end
  return true
end


function on_inv_boxes_found( victim, vdata )
  for _, v_obj in ipairs( vdata.inv_boxes ) do
    local object = alife():object( v_obj.id )
    if object then
      -- Idler ++-- если нычка доступна - можно шмонать
      if inv_box_is_avail( victim, object ) then
        if object:section_name() == "dsh_treasure_item" then
          dsh_rukzak.on_inv_box_found( object.id, victim )
        elseif items[ v_obj.id ] then
          for _, v_itA in ipairs( items[ v_obj.id ] ) do
            local itA = alife():object( v_itA.id )
            if
              itA
              and itA.parent_id == v_obj.id
              and itA:name() == v_itA.name
            then
              -- Решим, подбираем или нет?
              if is_valuable( itA ) then
                pick_item( victim, itA )
              end
            end
          end
        end
        victim:set_rank( victim:rank() + rate_art_found )
      end
    end
  end
end


function pick_item( npc, obj )
  local section = obj:section_name()
  local new     = alife():create(
    section,
    npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
    npc.id
  )
  ASSERT( new, "can't create new %s", section )
  local pk = get_netpk( obj, 1 )
  if pk:isOk() then
    local data = pk:get()
    local cd   = data.custom_data:getString()
    if cd and cd ~= "" then
      local new_pk = get_netpk( new, 1 )
      if new_pk:isOk() then
        local new_data = pk:get()
        new_data.custom_data:setString( cd )
        new_pk:set( new_data )
      end
    end
  end
  if not items[ npc.id ] then items[ npc.id ] = {} end
  table.insert(
    items[ npc.id ],
    {
      id    = new.id,
      lname = object_level_name( new ),
      name  = new:name(),
    }
  )
  -- Idler++-- корректируем хабар в помеченных тайниках
  gps_habar.insert_item( npc.id, new )
  if
    obj.parent_id
    and items[ obj.parent_id ] and table.getn( items[ obj.parent_id ] ) > 0
  then
    for z = 1, table.getn( items[ obj.parent_id ] ) do
      if items[ obj.parent_id ][ z ].id == obj.id then
        -- Idler++-- корректируем хабар в помеченных тайниках
        gps_habar.remove_item( obj.parent_id, items[ obj.parent_id ][ z ] )
        table.remove( items[ obj.parent_id ], z )
        break
      end
    end
  end
  alife():release( alife():object( obj.id ), true )
  return new
end


function get_item_cost( item )
  return get_float( item:section_name(), "cost", 0 )
end


-- Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.
-- Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
-- Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class
-- Оставили одно, которое лучше (а), но патронов нет (б) (%)
-- Одно, которое лучше (а), но хуже (б) - в новости на продажу
-- Остальное на продажу
-- Патроны оставили только те, что подходят к (а), остальные на продажу
-- Для вояк - только родной калаш надо бы... Не продавать вобще?
-- Оставляем не более 2 аптечек и бинтов, антирада
-- Оставляем 1-2 гранаты (%)
-- Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
-- Еда, водка - не более 1-2 шт (%)
-- Броники наверное продаем...
-- Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
function process_trade( npc )
  local item_list = {}
  local sell_list = {}
  -- Имеет смысл проверять на наличие trade в секции [logic]...
  if
    is_npc_can_trade( npc )
    and items[ npc.id ] and table.getn( items[ npc.id ] ) > 0
  then
    local b_friend = false
    local m_comm   = npc:community()
    if friends_comm[ m_comm ] then
      if npc.name and npc:name() ~= "agr_ratcatcher" then
        b_friend = true
      end
    elseif m_comm == "zombied" then
      return
    end

    --Фильтруем квестовые items - always_keep_item
    for _, ov in ipairs( items[ npc.id ] ) do
      local obj = alife():object( ov.id )
      if obj and obj.parent_id == npc.id and obj:name() == ov.name then
        if
          not (
            always_keep_item[ obj:section_name() ]
            or protected_items.actor_items_keep( obj:section_name() )
          )
        then
          table.insert( item_list, obj )
        end
      end
    end

    if item_list and table.getn( item_list ) > 0 then
      table.sort(
        item_list,
        function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
      )
      -- Выберем, что за оружие оставит себе NPC.
      local cnt_medkit    = 0
      local cnt_antirad   = 0
      local cnt_bandage   = 0
      local cnt_grenade   = 0
      local cnt_food      = 0
      local cnt_drink     = 0
      local cnt_torch     = 0
      local cnt_pda       = 0
      local cnt_radio     = 0
      local cnt_guitar    = 0
      local cnt_harmonica = 0
      local cnt_binocular = 0
      local cnt_knife     = 0
      local cnt_arts      = 0
      local cnt_detector  = 0
      local cnt_mparts    = 0
      local weapons       = {}
      local ammo          = {}
      for _, v in ipairs( item_list ) do
        local sect = v:section_name()
        if isWeaponGrenade( v ) then
          cnt_grenade = cnt_grenade + 1
          if cnt_grenade > 3 then
            table.insert( sell_list, v )
          end
        elseif
          string.find( sect, "wpn_addon_scope", 1, true )
          or string.find( sect, "wpn_addon_silencer", 1, true )
          or string.find( sect, "wpn_addon_grenade_launcher", 1, true )
        then
          table.insert( sell_list, v )
        elseif sect == "wpn_knife" then
          cnt_knife = cnt_knife + 1
          if cnt_knife > 1 then
            table.insert( sell_list, v )
          end
        elseif isWeapon( v ) then
          local ac = get_string( sect, "ammo_class" )
          if ac and ac ~= "" then
            table.insert( weapons, {
              obj         = v,
              ammo        = parse_names( ac ),
              sorted_ammo = sort_ammo_classes( ac ),
            })
          else
            table.insert( weapons, { obj = v } )
          end
        elseif string.find( sect, "^ammo_" ) then
          if ammo[ sect ] then
            table.insert( ammo[ sect ].objs, v )
          else
            ammo[ sect ] = { objs = { v } }
          end
        elseif
          dsh.is_artefact( sect )
          or string.find( sect, "mutant_af_", 1, true )
        then
          -- артефакты продаем, но не сразу
          if math.random() < 0.1 then
            table.insert( sell_list, v )
          end
        elseif sect == "device_torch" then
          cnt_torch = cnt_torch + 1
          if cnt_torch > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "device_pda" then
          cnt_pda = cnt_pda + 1
          if cnt_pda > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "hand_radio" then
          cnt_radio = cnt_radio + 1
          if cnt_radio > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "harmonica_a" then
          cnt_harmonica = cnt_harmonica + 1
          if cnt_harmonica > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "guitar_a" then
          cnt_guitar = cnt_guitar + 1
          if cnt_guitar > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "binocular_a" or sect == "wpn_binoc" then
          cnt_binocular = cnt_binocular + 1
          if cnt_binocular > 1 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "yad"
          or sect == "medkit"
          or sect == "medkit_army"
          or sect == "medkit_scientic"
        then
          cnt_medkit = cnt_medkit + 1
          if cnt_medkit > 4 then
            table.insert( sell_list, v )
          end
        elseif sect == "antirad" then
          cnt_antirad = cnt_antirad + 1
          if cnt_antirad > 3 then
            table.insert( sell_list, v )
          end
        elseif sect == "bandage" then
          cnt_bandage = cnt_bandage + 1
          if cnt_bandage > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "bread_a"
          or sect =="bread"
          or sect == "kolbasa"
          or sect == "kolbasa_a"
          or sect == "conserva"
        then
          cnt_food = cnt_food + 1
          if cnt_food > 4 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "vodka_a"
          or sect =="vodka"
          or sect == "energy_drink"
        then
          cnt_drink = cnt_drink + 1
          if cnt_drink > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "detector_simple"
          or sect =="detector_advances"
          or sect == "detector_elite"
        then
          cnt_detector = cnt_detector + 1
          if cnt_detector > 1 then
            table.insert( sell_list, v )
          end
        elseif get_bool( sect, "monster_part", false ) then
          if cnt_mparts > 2 then
            table.insert( sell_list, v )
          else
            if math.random() < 0.1 then
              table.insert( sell_list, v )
            else
              cnt_mparts = cnt_mparts + 1
            end
          end
        elseif string.find( sect, "outfit" ) or string.find( sect, "exo" ) then
          table.insert( sell_list, v )
        end
      end

      local modes = rx_wmgr.read_wm_modes(
        npc:community(), ranks.get_obj_rank_name( npc ), npc:section_name()
      )
      local weapons_types = {}
      for _, i in ipairs( modes.types ) do
        weapons_types[ i.t ] = {}
      end
      for _, t in ipairs( weapons ) do
        local sect   = t.obj:section_name()
        local params = rx_wmgr.read_wpn_params( sect )
        t.ammo_mag_size = params.mag
        t.prm = 0
        if modes.mode1 == "1" then
          t.prm = params.cst + modes.addcost
        elseif modes.mode1 == "2" then
          local dst = params.bullet_speed -- params.dst
          local kf  = rx_wmgr.wm_modes.koeffs[ modes.koeffs ]
          t.prm = ( params.dmg * kf.dmg )
            + ( params.rpm * kf.rpm )
            + ( dst * kf.dst )
            + ( ( 50 / params.dsp ) * kf.dsp )
        elseif modes.mode1 == "3" then
          t.prm = rx_wmgr.wm_modes.priors[ modes.priors ][ sect ] or 0
        end
        local pk = get_netpk( t.obj, 1 )
        ASSERT(
          pk:isOk(), "[%s]: can't parse netpk: %s",
          script_name(), t.obj:name()
        )
        local data = pk:get()
        t.pk           = pk
        t.pk_data      = data
        t.cond         = data.condition
        t.has_gl       = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.gl
        ) ~= 0
        t.has_scope    = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.scope
        ) ~= 0
        t.has_silencer = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.silencer
        ) ~= 0
        local pr = 0
        if t.has_gl then
          pr = pr + t.prm * modes.grenadelauncher / 100
        end
        if t.has_scope then
          pr = pr + t.prm * modes.scope / 100
        end
        if t.has_silencer then
          pr = pr + t.prm * modes.silencer / 100
        end
        for _, v in ipairs( modes.types ) do
          if v.t == params.typ then
            pr = pr + t.prm * v.p / 100
            break
          end
        end
        t.prm = t.prm + pr + t.obj.id / 100000 + t.cond * t.prm / 50
        if weapons_types[ params.typ ] then
          table.insert( weapons_types[ params.typ ], t )
        else
          weapons_types[ params.typ ] = { t }
        end
      end

      local our_weapons = {}
      for k, v in pairs( weapons_types ) do
        table.sort(
          v, function( a, b ) return a.prm > b.prm end
        )
        -- Так, теперь у нас отсортированны все пушки НПС. Найдем ту,
        -- для которой есть патроны...
        local b_self = false
        local b_best = false
        for _, w in ipairs( v ) do
          local b_ammo = false
          local vac    = w.ammo
          if vac and table.getn( vac ) > 0 then
            for kk, vv in ipairs( vac ) do
              if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
                -- Так, патроны есть.
                b_ammo = true
                break
              end
            end
          end
          if is_broken_wpn( w ) then
            table.insert( sell_list, w.obj )
          elseif ( not b_self ) and b_ammo then
            b_self = true
            table.insert( our_weapons, w )
          elseif not b_best then
            if b_self then
              -- если собственное оружие у нас самое лучшее, т.е. оно
              -- было первым в списке, то запасное нам не нужно.
              table.insert( sell_list, w.obj )
            else
              -- к самому лучшему оружию нет патронов. Сохраним его и
              -- подождем, когда появятся патроны.
              b_best = true
              table.insert( our_weapons, w )
            end
          else
            table.insert( sell_list, w.obj )
          end
        end
      end

      process_ammo_trade( sell_list, ammo, npc, our_weapons )
      if weapon_repair_allowed then
        process_weapon_repair( our_weapons )
      end
      for _, w in ipairs( our_weapons ) do
        if w.commit then
          w.pk:set( w.pk_data )
          w.commit = nil
        end
      end

      -- Так, с оружием закончили...
      -- Все, что осталось - надо продать.
      -- 1 самое дорогое можно попробовать через новости...
      -- ... ну и когда-нибудь, как фишка ляжет, наконец от него избавиться.
      local money = 0
      if b_friend and table.getn( sell_list ) > 0 and math.random() < 0.9 then
        table.sort(
          sell_list,
          function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
        )
        local zz = sell_list[ 1 ]
        if get_item_cost( zz ) >= sell_limit then
          -- Продадим через новости.
          news_main.on_offline_trade( npc, zz )
          table.remove( sell_list, 1 )
        end
      end
      for _, vv in ipairs( sell_list ) do
        local cost = get_item_cost( vv )
        if cost > 0 then
          local coeff = math.random( 30, 50 ) / 100
          local price = math.floor( cost * coeff )
          money = money + price
          -- Почистим items
          if items[ npc.id ] and table.getn( items[ npc.id ] ) > 0 then
            for z, item in ipairs( items[ npc.id ] ) do
              if item.id == vv.id then
                table.remove( items[ npc.id ], z )
                -- Idler++-- корректируем хабар в помеченных тайниках
                gps_habar.remove_item( npc.id, item )
                break
              end
            end
          end
          alife():release( alife():object( vv.id ), true )
        end
      end
      if money > 0 then
        local pk = get_netpk( npc, 1 )
        if pk:isOk() then
          local data = pk:get()
          if data.money then money = money + data.money end
          data.money = money
          pk:set( data )
        end
      end
    end
  end
end


function process_ammo_trade( sell_list, ammo, npc, our_weapons )
  for _, w in ipairs( our_weapons ) do
    local data = w.pk_data
    if data.ammo_elapsed < w.ammo_mag_size then
      -- log2(
      --   "[%s]: %s has no enough ammo in mag for %s: %s < %s, fixed",
      --   script_name(), npc:name(), w.obj:section_name(), data.ammo_elapsed,
      --   w.ammo_mag_size
      -- )
      data.ammo_elapsed = w.ammo_mag_size
      w.commit          = true
    end
    local vac, sorted_ammo = w.ammo, w.sorted_ammo
    if vac and table.getn( vac ) > 0 then
      local params = {}
      for _, t in ipairs( sorted_ammo ) do
        params[ t.sect ] = t
      end
      local has_ammo
      for i = table.getn( sorted_ammo ), 1, -1 do
        local sect = sorted_ammo[ i ].sect
        if ammo[ sect ] and table.getn( ammo[ sect ].objs ) > 0 then
          if has_ammo then
            if not ammo[ sect ].inuse then
              ammo[ sect ].sell = true
              -- log2(
              --   "[%s]: %s has extra ammo type for %s: %s < %s, marked for sell",
              --   script_name(), npc:name(), w.obj:section_name(), sect, has_ammo
              -- )
            end
          else
            local loaded_sect = vac[ data.ammo_type + 1 ]
            if params[ loaded_sect ].hit < sorted_ammo[ i ].hit then
              -- log2(
              --   "[%s]: %s uses weak ammo for %s: %s(%s) < %s(%s), changed",
              --   script_name(), npc:name(), w.obj:section_name(),
              --   loaded_sect, params[ loaded_sect ].hit,
              --   sorted_ammo[ i ].sect, sorted_ammo[ i ].hit
              -- )
              data.ammo_type = sorted_ammo[ i ].ammo_class - 1
              w.commit       = true
            end
            ammo[ sect ].inuse = true
            ammo[ sect ].sell  = false
            has_ammo = sect
          end
        end
      end
      if not has_ammo then
        local ammo_class = data.ammo_type + 1
        local sect       = vac[ ammo_class ]
        -- log2(
        --   "[%s]: %s has no ammo in inv for %s, spawned %s",
        --   script_name(), npc:name(), w.obj:section_name(), sect
        -- )
        local sobj = alife():create(
          sect,
          npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
          npc.id
        )
        table.insert(
          items[ npc.id ],
          {
            id    = sobj.id,
            lname = object_level_name( npc ),
            name  = sobj:name(),
          }
        )
        ammo[ sect ] = {
          [ "inuse" ] = true,
          [ "objs"  ] = { sobj },
        }
      end
    end
  end
  for sect, v in pairs( ammo ) do
    if not v.sell then
      v.props = {}
      for _, sobj in ipairs( v.objs ) do
        local pk = get_netpk( sobj, 1 )
        ASSERT(
          pk:isOk(), "[%s]: can't parse netpk: %s", script_name(), sobj:name()
        )
        table.insert( v.props, {
          sobj = sobj,
          pk   = pk,
          data = pk:get(),
        })
      end
      v.objs = nil
    end
  end
  for sect, v in pairs( ammo ) do
    if v.sell then
      if table.getn( v.objs ) > 0 then
        -- log2(
        --   "[%s]: %s has marked %s ammo box(es) of %s, sold",
        --   script_name(), npc:name(), table.getn( v.objs ), sect
        -- )
        for _, sobj in ipairs( v.objs ) do
          table.insert( sell_list, sobj )
        end
      end
    else
      if table.getn( v.props ) > 1 then
        table.sort(
          v.props,
          function( a, b ) return a.data.ammo_left > b.data.ammo_left end
        )
        while table.getn( v.props ) > 1 do
          local t = table.remove( v.props )
          table.insert( sell_list, t.sobj )
          -- log2(
          --   "[%s]: %s has extra ammo box of %s: %s <= %s, sold",
          --   script_name(), npc:name(), sect, t.data.ammo_left,
          --   v.props[ 1 ].data.ammo_left
          -- )
        end
      end
      if v.inuse then
        local box_size = get_u32( sect, "box_size" )
        for _, t in ipairs( v.props ) do
          if t.data.ammo_left < box_size then
            -- log2(
            --   "[%s]: %s has incomplete ammo box of %s: %s < %s, fixed",
            --   script_name(), npc:name(), sect, t.data.ammo_left, box_size
            -- )
            local data = t.data
            data.ammo_left = box_size
            t.pk:set( data )
          end
        end
      end
    end
  end
end


function is_broken_wpn( w )
  return w.cond < rx_wmgr.wm_modes.min_cond
end


function process_weapon_repair( our_weapons )
  for _, w in ipairs( our_weapons ) do
    if w.cond < 1 and not is_broken_wpn( w ) then
      local data = w.pk_data
      if data.condition < 0.9 then
        data.condition = data.condition + 0.1
      else
        data.condition = 1
      end
      w.cond   = data.condition
      w.commit = true
    end
  end
end
function process_weapon_repair_allowed() end


function sobj_is_far( obj, distance )
  local result = true
  -- на одном ли уровне?
  if object_level_name( obj ) == level.name() then
    -- Достаточно ли далеко?
    if obj.position:distance_to( db.actor:position() ) < distance then
      result = false
    end
  end
  return result
end


function box_is_protected( v )
  -- проверяем по ID объекта
  if protected.ids[ v.id ] then return true end
  -- проверяем по имени объекта
  for _, o in ipairs( protected.names ) do
    if o == v:name() then
      return true
    end
  end
  -- проверяем по story ID объекта
  for _, o in ipairs( protected.story_ids ) do
    if o == v.m_story_id then
      return true
    end
  end
  -- проверяем по секции объекта
  for _, o in ipairs( protected.sections ) do
    if o == v:section_name() then
      return true
    end
  end
  return false
end


function is_valuable( item )
  local result = false
  local cost   = get_item_cost( item )
  if IAmAWeapon[ item:clsid() ] and cost >= 1000 then
    result = true
  elseif cost >= 800 then
    result = true
  end
  return result
end


local sorted_ammo_classes = {}
function sort_ammo_classes( ac )
  if not sorted_ammo_classes[ ac ] then
    local sorted = {}
    for i, sect in ipairs( parse_names( ac ) ) do
      local k_hit     = get_float( sect, "k_hit",     1 )
      local buck_shot = get_float( sect, "buck_shot", 1 )
      table.insert( sorted, {
        ammo_class = i,
        hit        = k_hit * buck_shot,
        sect       = sect,
      })
    end
    table.sort(
      sorted, function( a, b ) return a.hit < b.hit end
    )
    sorted_ammo_classes[ ac ] = sorted
  end
  return sorted_ammo_classes[ ac ]
end
