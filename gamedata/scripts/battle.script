-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_monster_death",  fun = this.on_monster_death })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_net_destroy })
  sm:subscribe({ signal = "on_monster_spawn",  fun = this.on_monster_spawn })
  sm:subscribe({ signal = "on_spawn", fun = this.restore_deferred_battles })
end


function on_monster_spawn( obj, binder )
  if not has_alife_info( "battle" ) then return end
  if obj:alive() then return end
  local s = {
    [ "signal" ] = "on_update",
    [ "self"   ] = obj,
    [ "fun"    ] = this.cleanup,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end


function on_monster_death( obj, who )
  local binder = obj:binded_object()
  on_monster_spawn( obj, binder )
end


function on_net_destroy( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ script_name() .. ".subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
    binder[ script_name() .. ".subscribed" ] = nil
  end
end


function add_deferred_battle( lvl, btl, wave )
  log2(
    "[%s]: add deferred battle on %s: %s, %s, %s",
    script_name(), level.name(), lvl, btl, wave
  )
  local var_name = script_name() .. ".deferred." .. lvl
  local deferred = ogse.load_var_safe( var_name ) or {}
  table.insert( deferred, { btl, wave } );
  ogse.save_var( var_name, deferred, "array_template", { "u8", "u8" } )
end


function restore_deferred_battles()
  local var_name = script_name() .. ".deferred." .. level.name()
  local deferred = ogse.load_var_safe( var_name )
  if not deferred then return end
  for i, b in ipairs( deferred ) do
    local btl, wave = unpack( b )
    log2(
      "[%s]: restore deferred battle on %s: %s, %s",
      script_name(), level.name(), btl, wave
    )
    battle_timer( 30 * i, level.name(), btl, wave )
  end
  ogse.delete_var( var_name )
end


-- Универсальный скрипт больших битв с монстрами/неписями
-- Поддерживаются:
-- Спавн по таймеру каждой волны монстров
-- Передышки между волнами
-- Спавн неподалеку от гг рюкзака с патронами/аптечками по время
-- передышки с выдачей информации через СМС
-- Монстры спавнятся не вокруг ГГ, а в определенном секторе справа,
-- слева или сзади ГГ рандомно, на указанном удалении. Спереди не
-- спавнятся.
-- "Быстрый" уборщик, который во избежание тормозов убирает скопления
-- трупов монстров при удалении гг от них на определенное расстояние
-- начало битвы запускается так:
-- amk.start_timer("battle", 0, {"level", num, 1})
-- где
-- level - уровень, на котором битва;
-- num - номер битвы на уровне;
-- 1 - начинаем с первой волны
--
-- Замечания:
--
-- Вместо монстров можно прописывать секции неписей (монолита,
-- например). Только уборщик не будет убирать их трупы.
--
-- Если в одной из волн прописать секции дружественных неписей - то
-- они также заспавнятся и будут воевать на стороне гг.

-- расстояние от ГГ в м, на котором уборщик убирает трупы
local cleanup_distance          = 50
-- время передышки в секундах (добавляется ко времени следущей волны
-- +-20%)
local rest_timeout              = 120
-- минимальная дистанция, на которой можно спавнить волну. если
-- подходящий вертекс на указанном расстоянии или дальше не находится
-- (гг заныкался в закутке - не находится в открытом месте) то спавн
-- волны откладывается
local min_good_distance         = 40
-- время в реальных с, на которое откладывается спавн след волны, если
-- гг заныкался
local min_good_distance_timeout = 10

-- общее количество заспавненных монстров с момента последней
-- передышки
local monster_cnt = 0

-- лекарства для рюкзака
local medkits = { "medkit", "medkit_army", "medkit_scientic", "bandage" }

-- таблица настроек битв
local battles = battle_battles.battles


-- Основной обработчик. Вызывает сам себя через таймер. И первый
-- запуск нужно делать тоже через таймер.
function show_must_go_on_delayed( lvl, btl, wave )
  show_must_go_on_real( lvl, tonumber( btl ), tonumber( wave ) )
end


function show_must_go_on_real( lvl, btl, wave )
  local cur_wave = battles[ lvl ][ btl ][ wave ]

  -- сменили локу - битва закончена
  if not cur_wave.any_level then
    if level.name() ~= lvl then
      add_deferred_battle( lvl, btl, wave )
      show_off()
      return
    end
  end

  db.actor:give_info_portion( "battle" )

  -- спавн монстров/неписей
  if cur_wave.enemy then
    -- проверяем, не заныкался ли где гг в закутке - можно ли
    -- заспавнить на нормальном расстоянии от него
    local pos, lv
    if cur_wave.dist then
      pos, lv = get_pos( cur_wave.dist, get_sector() )
      if pos:distance_to( db.actor:position() ) < min_good_distance then
        -- заныкался - откладываем спавн, пока гг не выйдет из укрытия
        battle_timer( min_good_distance_timeout, lvl, btl, wave )
        return
      end
    end
    ASSERT(
      ( pos and lv ),
      "[%s]: [%s, %s, %s]: enemy without dist found",
      script_name(), lvl, btl, wave
    )
    for s, p in pairs( cur_wave.enemy ) do
      for i = 1, p do
        dsh.create_free_mob( s, pos, lv, db.actor:game_vertex_id() )
        monster_cnt = monster_cnt + 1
      end
    end
  end

  if cur_wave.rest then
    -- есть перерыв
    if cur_wave.rukzak then
      -- есть тайник - спавним
      reinforcement_timer(
        math.random( cur_wave.timeout * 0.8, cur_wave.timeout * 1.2 ),
        lvl, btl, wave, monster_cnt
      )
    end
    -- даем передышку
    cur_wave.timeout = cur_wave.timeout + rest_timeout
    monster_cnt = 0
  end

  if cur_wave.info then
    -- выдаем поршень
    db.actor:give_info_portion( cur_wave.info )
  end
  if cur_wave.func then
    -- выполняем функцию
    loadstring( cur_wave.func )()
  end
  if cur_wave.tip then
    -- выдаем смс
    news_manager.send_tip( db.actor, cur_wave.tip, nil, nil, 5000 )
  end

  -- следующая волна
  wave = wave + 1
  if battles[ lvl ][ btl ][ wave ] then
    -- есть следующая волна - запускаем
    battle_timer(
      math.random( cur_wave.timeout * 0.8, cur_wave.timeout * 1.2 ),
      lvl, btl, wave
    )
  else
    -- конец битвы
    show_off()
  end
end


-- подкрепление в виде рюкзака
-- текущая волна должна идти параметром приватно, т.к. наверху уже
-- следующая волна на очереди
function reinforcement_delayed( lvl, btl, wave, last_monster_cnt )
  reinforcement(
    lvl, tonumber( btl ), tonumber( wave ), tonumber( last_monster_cnt )
  )
end


function reinforcement( lvl, btl, wave, last_monster_cnt )
  local cur_wave = battles[ lvl ][ btl ][ wave ]

  -- сменили локу - битва закончена
  if not cur_wave.any_level then
    if level.name() ~= lvl then
      show_off()
      return
    end
  end

  -- рюкзак спавним с меткой и не далее 10 м от гг, чтобы нашел
  local pos, lv = get_pos( math.random( 3, 10 ) )
  local ruk = alife():create(
    "m_inventory_box", pos, lv, db.actor:game_vertex_id()
  )
  level.map_add_object_spot_ser( ruk.id, "treasure", "Рюкзак с припасами" )

  -- аптечки
  if cur_wave.medkit then
    for i = 1, math.random(0, cur_wave.medkit ) do
      alife():create(
        medkits[ math.random( table.getn( medkits ) ) ],
        vector():set( 0, 0, 0 ), 0, 0, ruk.id
      )
    end
  end

  -- патроны/подствол
  if cur_wave.ammo or cur_wave.podstvol then
    for i =1, 2 do
      if db.actor:item_in_slot( i ) then
        local wpn = db.actor:item_in_slot( i )

        if cur_wave.ammo then
          for j = 1, math.floor( last_monster_cnt * cur_wave.ammo ) do
            local list = rx_utils.parse_list_new(
              nil, wpn:section(), "ammo_class"
            )
            local section = list[ math.random( table.getn( list ) ) ]
            alife():create_ammo(
              section, vector():set( 0, 0, 0), 0, 0, ruk.id,
              rx_utils.read_from_ini( nil, section, "box_size", 1, 3 )
            )
          end
        end

        if cur_wave.podstvol and rx_utils.addon_attached( wpn, "gl" ) then
          for j = 1, math.floor( last_monster_cnt *cur_wave.podstvol ) do
            local list = rx_utils.parse_list_new(
              nil, wpn:section(), "grenade_class"
            )
            local section = list[ math.random( table.getn( list ) ) ]
            alife():create( section, vector():set( 0, 0, 0 ), 0, 0, ruk.id )
          end
        end
      end
    end
  end

  -- разный допхабар
  if cur_wave.items then
    for s, p in pairs( cur_wave.items ) do
      for i = 1, p do
        alife():create( s, vector():set(0,0,0), 0, 0, ruk.id )
      end
    end
  end

  -- выдаем смс
  if cur_wave.sms then
    news_manager.send_tip( db.actor, cur_wave.sms, nil, nil, 5000 )
  end
end


-- выбор сектора для спавна
function get_sector()
  return math.random( 3 ) * 90
end


-- определение места спавна. параметры:
-- dist - расстояние от ГГ
-- sector - в каком секторе спавнить (сзади, справа, или слева) от
-- ГГ. Сектор получать функцией get_sector(). Если не указан -
-- выполняется рандомный спавн вокруг гг (не нужно указывать для
-- рюкзаков)
-- Возвращает 2 значения: позицию спавна и левел_вертекс
function get_pos( dist, sector )
  local random_spawn = ( sector == nil )
  if not sector then sector = math.random( 360 ) end

  local actor_pos   = db.actor:position()
  -- угол обзора гг, если sector задан - то в видимой зоне не спавним
  local actor_fov   = math.rad( device().fov / 2 )
  local ai_step     = 0.7 -- шаг AI сетки
  local math_pi_180 = 180 / math.pi
  local pi2         = math.pi * 2

  -- выравниваем вектора по горизонтали
  local dir = device().cam_dir
  dir = vector():set( dir.x, 0, dir.z ):normalize()
  -- вектор взгляда актора, выравненный горизонтально
  local actor_dir = dir

  -- ищем вертекс по сектору
  dir = vector_rotate_y( dir, sector )
  while dist >= ai_step do
    -- итератор вращения направления
    local rotate_angle = math.asin( ai_step / dist )
    local cur_angle, cur_dir = 0, dir
    while math.abs( cur_angle ) < pi2 do
      local d1 = actor_dir:normalize()
      local d2 = cur_dir:normalize()
      if math.acos( d1:dotproduct( d2 ) ) > actor_fov then
        -- подходящий угол, ищем вертекс
        -- нужная нам позиция
        local pos     = vector():mad( actor_pos, cur_dir, dist )
        local vert_ok = level.vertex_id_by_pos( pos )
        if vert_ok ~= -1 then
          local vert_pos = level.vertex_position( vert_ok )
          if no_anomaly_in( vert_pos ) then
            return vert_pos, vert_ok
          end
        end
      end
      -- поворачиваем направление поиска
      cur_angle = cur_angle + rotate_angle
      cur_dir   = vector_rotate_y( cur_dir, rotate_angle * math_pi_180 )
    end
    dist = dist - ai_step
  end

  -- прошлись по спирали и ничего не нашли
  return actor_pos, db.actor:level_vertex_id()
end


function show_off()
  monster_cnt = 0
  db.actor:disable_info_portion( "battle" )
end


-- "быстрый" уборщик
-- ускоренное удаление трупов при очень больших битвах. вызывается из апдейта
-- монстров
function cleanup( obj )
  ogse_signals.get_mgr():reschedule( 1000 )
  local dist = db.actor:position():distance_to( obj:position() )
  if dist > cleanup_distance then
    alife():release( alife():object( obj:id() ), true )
  end
end


-- проверка попадания точки спавна в аномалию
function no_anomaly_in( pos )
  local anom_id, anom_pos, anom_radius, dist = amk_anoms.get_nearest_anomaly_for_pos( pos )
  return ( not anom_id ) or dist > 3
end


function battle_timer( time, lvl, btl, wave )
  ogse_st_mgr.start_timer(
    ( script_name() .. "." .. lvl .. "." .. btl ),
    time, script_name() .. ".show_must_go_on_delayed",
    lvl, btl, wave
  )
end


function reinforcement_timer( time, ... )
  ogse_st_mgr.start_timer(
    nil, time, script_name() .. ".reinforcement_delayed", ...
  )
end
