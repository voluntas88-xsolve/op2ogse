-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_monster_death",  fun = this.on_monster_death })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_net_destroy })
  sm:subscribe({ signal = "on_monster_spawn",  fun = this.on_monster_spawn })
end


function on_monster_spawn( obj, binder )
  if not has_alife_info( "battle" ) then return end
  if obj:alive() then return end
  local s = {
    [ "signal" ] = "on_update",
    [ "self"   ] = obj,
    [ "fun"    ] = this.cleanup,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end


function on_monster_death( obj, who )
  local binder = obj:binded_object()
  on_monster_spawn( obj, binder )
end


function on_net_destroy( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ script_name() .. ".subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
    binder[ script_name() .. ".subscribed" ] = nil
  end
end


-- Универсальный скрипт больших битв с монстрами/неписями
-- Поддерживаются:
-- Спавн по таймеру каждой волны монстров
-- Передышки между волнами
-- Спавн неподалеку от гг рюкзака с патронами/аптечками по время
-- передышки с выдачей информации через СМС
-- Монстры спавнятся не вокруг ГГ, а в определенном секторе справа,
-- слева или сзади ГГ рандомно, на указанном удалении. Спереди не
-- спавнятся.
-- "Быстрый" уборщик, который во избежание тормозов убирает скопления
-- трупов монстров при удалении гг от них на определенное расстояние
-- начало битвы запускается так:
-- amk.start_timer("battle", 0, {"level", num, 1})
-- где
-- level - уровень, на котором битва;
-- num - номер битвы на уровне;
-- 1 - начинаем с первой волны
--
-- Замечания:
--
-- Вместо монстров можно прописывать секции неписей (монолита,
-- например). Только уборщик не будет убирать их трупы.
--
-- Если в одной из волн прописать секции дружественных неписей - то
-- они также заспавнятся и будут воевать на стороне гг.

-- расстояние от ГГ в м, на котором уборщик убирает трупы
local cleanup_distance          = 50
-- время передышки в секундах (добавляется ко времени следущей волны
-- +-20%)
local rest_timeout              = 120
-- минимальная дистанция, на которой можно спавнить волну. если
-- подходящий вертекс на указанном расстоянии или дальше не находится
-- (гг заныкался в закутке - не находится в открытом месте) то спавн
-- волны откладывается
local min_good_distance         = 40
-- время в реальных с, на которое откладывается спавн след волны, если
-- гг заныкался
local min_good_distance_timeout = 10

-- общее количество заспавненных монстров с момента последней
-- передышки
local monster_cnt = 0

-- лекарства для рюкзака
local medkits = { "medkit", "medkit_army", "medkit_scientic", "bandage" }

-- таблица настроек битв
local battles = battle_battles.battles


-- Основной обработчик. Вызывает сам себя через таймер. И первый
-- запуск нужно делать тоже через таймер.
function show_must_go_on( params_string )
  local data = amk.unpack_array_from_string( params_string )
  local lvl, btl, wave = data[ 1 ], tonumber( data[ 2 ] ), tonumber( data[ 3 ] )
  show_must_go_on_real( lvl, btl, wave )
end


function show_must_go_on_delayed( lvl, btl, wave )
  show_must_go_on_real( lvl, tonumber( btl ), tonumber( wave ) )
end


function show_must_go_on_real( lvl, btl, wave )
  local cur_wave = battles[ lvl ][ btl ][ wave ]

  -- сменили локу - битва закончена
  if not cur_wave.any_level then
    if level.name() ~= lvl then
      show_off()
      return
    end
  end

  local sector = get_sector()
  db.actor:give_info_portion( "battle" )

  -- проверяем, не заныкался ли где гг в закутке - можно ли заспавнить
  -- на нормальном расстоянии от него
  if cur_wave.dist then
    local pos, lv = get_pos( cur_wave.dist, sector )
    if pos:distance_to( db.actor:position() ) < min_good_distance then
      -- заныкался - откладываем спавн, пока гг не выйдет из укрытия
      battle_timer( min_good_distance_timeout, lvl, btl, wave )
      return
    end
  end

  -- спавн монстров/неписей
  if cur_wave.enemy then
    for s, p in pairs( cur_wave.enemy ) do
      for i =1, p do
        local pos, lv = get_pos( cur_wave.dist, sector )
        dsh.create_free_mob( s, pos, lv, db.actor:game_vertex_id() )
        monster_cnt = monster_cnt + 1
      end
    end
  end

  if cur_wave.rest then
    -- есть перерыв
    if cur_wave.rukzak then
      -- есть тайник - спавним
      reinforcement_timer(
        math.random( cur_wave.timeout * 0.8, cur_wave.timeout * 1.2 ),
        lvl, btl, wave, monster_cnt
      )
    end
    -- даем передышку
    cur_wave.timeout = cur_wave.timeout + rest_timeout
    monster_cnt = 0
  end

  if cur_wave.info then
    -- выдаем поршень
    db.actor:give_info_portion( cur_wave.info )
  end
  if cur_wave.func then
    -- выполняем функцию
    loadstring( cur_wave.func )()
  end
  if cur_wave.tip then
    -- выдаем смс
    news_manager.send_tip( db.actor, cur_wave.tip, nil, nil, 5000 )
  end

  -- следующая волна
  wave = wave + 1
  if battles[ lvl ][ btl ][ wave ] then
    -- есть следующая волна - запускаем
    battle_timer(
      math.random( cur_wave.timeout * 0.8, cur_wave.timeout * 1.2 ),
      lvl, btl, wave
    )
  else
    -- конец битвы
    show_off()
  end
end


-- подкрепление в виде рюкзака
-- текущая волна должна идти параметром приватно, т.к. наверху уже
-- следующая волна на очереди
function reinforcement_delayed( lvl, btl, wave, last_monster_cnt )
  reinforcement(
    lvl, tonumber( btl ), tonumber( wave ), tonumber( last_monster_cnt )
  )
end


function reinforcement( lvl, btl, wave, last_monster_cnt )
  local cur_wave = battles[ lvl ][ btl ][ wave ]

  -- сменили локу - битва закончена
  if not cur_wave.any_level then
    if level.name() ~= lvl then
      show_off()
      return
    end
  end

  -- рюкзак спавним с меткой и не далее 10 м от гг, чтобы нашел
  local pos, lv = get_pos( math.random( 3,10 ) )
  local ruk = alife():create(
    "m_inventory_box", pos, lv, db.actor:game_vertex_id()
  )
  level.map_add_object_spot_ser( ruk.id, "treasure", "Рюкзак с припасами" )

  -- аптечки
  if cur_wave.medkit then
    for i = 1, math.random(0, cur_wave.medkit ) do
      alife():create(
        medkits[ math.random( table.getn( medkits ) ) ],
        vector():set( 0, 0, 0 ), 0, 0, ruk.id
      )
    end
  end

  -- патроны/подствол
  if cur_wave.ammo or cur_wave.podstvol then
    for i =1, 2 do
      if db.actor:item_in_slot( i ) then
        local wpn = db.actor:item_in_slot( i )

        if cur_wave.ammo then
          for j = 1, math.floor( last_monster_cnt * cur_wave.ammo ) do
            local list = rx_utils.parse_list_new(
              nil, wpn:section(), "ammo_class"
            )
            local section = list[ math.random( table.getn( list ) ) ]
            alife():create_ammo(
              section, vector():set( 0, 0, 0), 0, 0, ruk.id,
              rx_utils.read_from_ini( nil, section, "box_size", 1, 3 )
            )
          end
        end

        if cur_wave.podstvol and rx_utils.addon_attached( wpn, "gl" ) then
          for j = 1, math.floor( last_monster_cnt *cur_wave.podstvol ) do
            local list = rx_utils.parse_list_new(
              nil, wpn:section(), "grenade_class"
            )
            local section = list[ math.random( table.getn( list ) ) ]
            alife():create( section, vector():set( 0, 0, 0 ), 0, 0, ruk.id )
          end
        end
      end
    end
  end

  -- разный допхабар
  if cur_wave.items then
    for s, p in pairs( cur_wave.items ) do
      for i = 1, p do
        alife():create( s, vector():set(0,0,0), 0, 0, ruk.id )
      end
    end
  end

  -- выдаем смс
  if cur_wave.sms then
    news_manager.send_tip( db.actor, cur_wave.sms, nil, nil, 5000 )
  end
end


-- выбор сектора для спавна
function get_sector()
  return math.random( 3 ) * 90
end


-- определение места спавна. параметры:
-- dist - расстояние от ГГ
-- sector - в каком секторе спавнить (сзади, справа, или слева) от
-- ГГ. Сектор получать функцией get_sector(). Если не указан -
-- выполняется рандомный спавн вокруг гг (не нужно указывать для
-- рюкзаков)
-- Возвращает 2 значения: позицию спавна и левел_вертекс
function get_pos( dist, sector )
  local not_random_spawn = sector ~= nil
  if not sector then sector = math.random( 360 ) end
  local pi2 = math.pi * 2
  local math_pi_180 = 180 / math.pi
  local dir = device().cam_dir
  local actor_pos = db.actor:position()
  local actor_lv  = db.actor:level_vertex_id()
  local dist_ok = 1.4           -- двойной шаг АИ сетки
  -- итератор вращения направления
  local rotate_angle = math.asin( dist_ok / dist )
  -- угол обзора гг, если sector задан - то в видимой зоне не спавним
  local actor_fov    = math.rad( device().fov / 2 )
  local cur_angle = 0
  local cur_pos, cur_vert, cur_dist
  local best_pos, best_dist     -- наилучшая найденная позиция

  -- выравниваем вектора по горизонтали
  dir = vector():set( dir.x, 0, dir.z ):normalize()
  -- вектор взгляда актора, выравненный горизонтально
  local actor_dir = dir

  -- ищем вертекс по сектору
  dir = vector_rotate_y( dir, sector )
  -- нужная нам позиция
  local pos     = vector():mad( actor_pos, dir, dist )
  -- ближайший подходящий вертекс, предложенный движком
  local vert_ok = level.vertex_in_direction( actor_lv, dir, dist )
  -- позиция ближайшего подходящего вертекса
  local pos_ok = level.vertex_position( vert_ok )

  if not_random_spawn then
    -- Не рандомый спавн вокруг - нужно искать поточнее в указанном секторе
    -- для начала исключаем очевидные случаи
    if pos:distance_to(pos_ok) < dist_ok or
      -- сплошная АИ сетка без препятствий - все нашлось само,
    actor_pos:distance_to( pos_ok ) > dist then
      -- либо актор далеко за аи сеткой - спавним в ближайшем
      -- подходящем вертексе.
    else
      -- несплошная АИ сетка или препятствия - ищем вариант получше
      -- выставляем направление вращения
      if math.random() < 0.5 then
        rotate_angle = -rotate_angle
      end
      -- продолжим искать от ближайшего предложенного движком вертекса
      -- в нужном нам направлении
      best_pos  = pos
      best_dist = dist
      repeat
        -- поворачиваем направление поиска
        cur_angle = cur_angle + rotate_angle
        dir = vector_rotate_y( dir, rotate_angle * math_pi_180 )
        if math.acos( actor_dir:dotproduct( dir ) ) > actor_fov then
          -- подходящий угол, ищем вертекс
          pos      = vector():mad( actor_pos, dir, dist )
          cur_vert = level.vertex_in_direction( actor_lv, dir, dist )
          cur_pos  = level.vertex_position( cur_vert )
          cur_dist = pos:distance_to( cur_pos )
          if cur_dist < dist_ok and no_anomaly_in( cur_pos ) then
            -- нашли вертекс - выходим
            pos_ok  = cur_pos
            vert_ok = cur_vert
            break
          end
          -- точного попадания пока нет - выбираем ближайший по
          -- расстоянию вертекс
          if cur_dist < best_dist and no_anomaly_in( cur_pos ) then
            best_pos  = cur_pos
            best_dist = cur_dist
            pos_ok    = cur_pos
            vert_ok   = cur_vert
          end
        end
      until math.abs( cur_angle ) > pi2
      -- обернулись вокруг - точного попадания нет, используем
      -- ближайший к точке
    end
  end

  return pos_ok, vert_ok
end


function show_off()
  monster_cnt = 0
  db.actor:disable_info_portion( "battle" )
end


-- "быстрый" уборщик
-- ускоренное удаление трупов при очень больших битвах. вызывается из апдейта
-- монстров
function cleanup( obj )
  ogse_signals.get_mgr():reschedule( 1000 )
  local dist = db.actor:position():distance_to( obj:position() )
  if dist > cleanup_distance then
    alife():release( alife():object( obj:id() ), true )
  end
end


-- проверка попадания точки спавна в аномалию
function no_anomaly_in( pos )
  local anom_id,anom_pos,anom_radius,dist = amk_anoms.get_nearest_anomaly_for_pos( pos )
  return not anom_id or dist - anom_radius > 5
end


function battle_timer( time, ... )
  ogse_st_mgr.start_timer(
    nil, time, script_name() .. ".show_must_go_on_delayed", ...
  )
end


function reinforcement_timer( time, ... )
  ogse_st_mgr.start_timer(
    nil, time, script_name() .. ".reinforcement_delayed", ...
  )
end
