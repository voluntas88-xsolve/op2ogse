-- -*- mode: lua; coding: windows-1251-dos -*-

local max_charge = 5


function attach( sm )
  sm:subscribe({
    signal = "on_before_script_autosave", fun = this.on_before_autosave
  })
  sm:subscribe({ signal = "on_first_update",   fun = this.on_first_update   })
  sm:subscribe({ signal = "on_mm_return_game", fun = this.on_mm_return_game })
  sm:subscribe({ signal = "on_save",           fun = this.on_save           })
end


local cur_charge, loaded_pos, loaded_time
function on_first_update()
  local obj = db.actor:object( "life_saver_af_known" )
  if obj then
    cur_charge = ogse.load_var_safe( "dsh_life_saver.cnt" ) or max_charge
    if cur_charge > max_charge then cur_charge = max_charge end
    obj:set_condition( cur_charge / max_charge )
    if cur_charge < max_charge then
      start_charging( obj )
    end
    loaded_pos  = db.actor:position()
    loaded_time = game.get_game_time()
  end
end


local discharge_onetime
function is_charged( onetime, quiet )
  local obj = db.actor:object( "life_saver_af_known" )
  if not obj then
    return db.actor:object( "life_saver_af_unknown" ) ~= nil
  end
  if obj:condition() > 0 then
    discharge_onetime = onetime
    return true
  elseif not quiet then
    dsh.say_blin()
  end
  return false
end


function discharge()
  local obj = db.actor:object( "life_saver_af_known" )
  if obj and obj:condition() > 0 then
    if cur_charge == max_charge then
      loaded_pos  = db.actor:position()
      loaded_time = game.get_game_time()
    end
    cur_charge = cur_charge - 1
    ASSERT(
      cur_charge >= 0, "[%s]: cur_charge < 0: %s", script_name(), cur_charge
    )
    obj:set_condition( cur_charge / max_charge )
    start_charging( obj )
  end
end


local charge_t
function start_charging( af )
  if charge_t then return end
  charge_t = dsh.wait_condition(
    function() return cur_charge == max_charge end,
    function() charge_t = nil end,
    function()
      ogse_signals.get_mgr():reschedule( math.random( 1000, 5000 ) )
      charging( af )
    end
  )
end


local time_factor = get_float( "alife", "time_factor" )

function charging( af )
  local cur_pos  = db.actor:position()
  local min_dist = isIndoor( level.name() ) and 50 or 200
  if
    cur_pos:distance_to( loaded_pos ) > min_dist
    or math.abs( cur_pos.y - loaded_pos.y ) > 10
    or game.get_game_time():diffSec( loaded_time ) > 300 * time_factor
  then
    cur_charge = cur_charge + 1
    af:set_condition( cur_charge / max_charge )
    loaded_pos  = db.actor:position()
    loaded_time = game.get_game_time()
  end
end


local autosave_prepared = false
function on_before_autosave()
  autosave_prepared = true
end


local onetime_saved = false
function on_mm_return_game()
  discharge_onetime = false
  onetime_saved     = false
end


function on_save()
  if utils.level_changing() then
    ogse.delete_var( "dsh.actor_pos"      )
    ogse.delete_var( "dsh.save_time"      )
    ogse.delete_var( "dsh_life_saver.cnt" )
  elseif cur_charge then
    if
      not ( autosave_prepared or ( discharge_onetime and onetime_saved ) )
    then
      discharge()
      if discharge_onetime then onetime_saved = true end
    end
    ogse.save_var( "dsh_life_saver.cnt", cur_charge, "u8" )
  end
  autosave_prepared = false
end


function got_life_saver( ver )
  local sobj
  if db.actor:has_info( "arhara_shaxter_start" ) then
    sobj = ogse.spawn_item_in_inv( "life_saver_af_known"   )
  else
    sobj = ogse.spawn_item_in_inv( "life_saver_af_unknown" )
  end
  level.client_spawn_manager():add(
    sobj.id, -1, function( id, obj )
      cur_charge = max_charge
    end
  )
end


function learned_life_saver()
  local obj = db.actor:object( "life_saver_af_unknown" )
  if obj then
    ogse.remove_item_from_inventory( obj )
  end
  local sobj = ogse.spawn_item_in_inv( "life_saver_af_known" )
  level.client_spawn_manager():add(
    sobj.id, -1, function( id, obj )
      cur_charge = max_charge
    end
  )
end
