-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_save", fun = this.save })
  sm:subscribe({ signal = "on_first_update", fun = this.on_spawn })
end


local parent_by_story = {
  [    3 ] = "trader",
  [    4 ] = "shustriy",
  [    6 ] = "wolf",
  [  500 ] = "barman",
  [  504 ] = "hunter",
  [  506 ] = "petrenko",
  [  507 ] = "dolg",
  [  510 ] = "drunk_dolg",
  [  515 ] = "mercenary",
  [  518 ] = "zastava_commander",
  [  607 ] = "lisiy",
  [  707 ] = "freedom",
  [  902 ] = "ecolog",
  [ 9613 ] = "green",
}

local story_by_parent = {
  barman            = 500,
  dolg              = 507,
  drunk_dolg        = 510,
  ecolog            = 902,
  freedom           = 707,
  green             = 9613,
  hunter            = 504,
  lisiy             = 607,
  mercenary         = 515,
  petrenko          = 506,
  shustriy          =   4,
  trader            =   3,
  wolf              =   6,
  zastava_commander = 518,
}

local return_task_by_type = {
  artefact        = "return_for_reward_bring",
  defend_lager    = "return_for_reward",
  eliminate_lager = "return_for_reward",
  find_item       = "return_for_reward_bring",
  kill_stalker    = "return_for_reward",
  monster_part    = "return_for_reward_bring",
}

-- типы циклических заданий для статистики
local cycle_task = {
  [ "artefact"        ] = true,
  [ "defend_lager"    ] = true,
  [ "eliminate_lager" ] = true,
  [ "find_item"       ] = true,
  [ "kill_stalker"    ] = true,
  [ "monster_part"    ] = true,
}

local map_locations = {
  [ "defend_lager"    ] = "defend_lager_location",
  [ "eliminate_lager" ] = "eliminate_lager_location",
  [ "find_item"       ] = "find_item_location",
  [ "kill_stalker"    ] = "kill_stalker_location",
}

local pda_task = xr_sound.get_safe_sound_object( "device\\pda\\pda_objective" )


local hash_to_id = {}
local id_to_hash = {}
local ct_to_hash = {}
local hash_to_ct = {}
-- хэш функция для строки (посмотреть литературу, на предмет оптимальной)
function stringhash( str )
  local mpl  = 1
  local hash = 0
  for i = 1, string.len( str ) do
    local val = string.byte( string.sub( str, i, i ) )
    hash = hash + mpl * val
    mpl  = mpl * 2
    if mpl == 512 then mpl = 1 end
  end
  return bit_and( hash, 65535 )
end


class "CRandomTask"
function CRandomTask:__init()
  -- На конструкторе вычитываем LTX и создаем заготовки квестов.
  self.task_ini       = sys_ini
  self.task_phrase_id = 100

  -- Итерируемся по всем настройкам фраз
  if not self.task_ini:section_exist( "task_manager.list" ) then
    abort( "There is no section [list] in task_manager.ltx" )
  end

  -- начальная установка
  self.task_info = {}
  for i = 0, self.task_ini:line_count( "task_manager.list" ) - 1 do
    local result, id, value = self.task_ini:r_line(
      "task_manager.list", i, "", ""
    )
    local hash = stringhash( id )
    if hash_to_id[ hash ] then
      abort( "Collision! Hash:%d id1:%s id2:%s", hash, hash_to_id[ hash ], id )
    end
    hash_to_id[ hash ] = id
    id_to_hash[ id   ] = hash
    local sect_id = "task_manager." .. id
    if not self.task_ini:section_exist( sect_id ) then
      abort( "There is no section [%s] in task_manager.ltx", id )
    end

    local curr_task_info = {}
    self.task_info[ id ] = curr_task_info
    if not self.task_ini:line_exist( sect_id, "type" ) then
      abort( "Task manager error: no type in section [%s]", id )
    end
    curr_task_info.type = self.task_ini:r_string( sect_id, "type" )
    curr_task_info.name = id
    if self.task_ini:line_exist( sect_id, "parent" ) then
      curr_task_info.parent       = self.task_ini:r_string( sect_id, "parent" )
      curr_task_info.complex_type = curr_task_info.type
        .. "_" .. curr_task_info.parent
    else
      curr_task_info.parent       = "nil"
      curr_task_info.complex_type = curr_task_info.type
    end
    local ct     = curr_task_info.complex_type
    local cthash = stringhash( ct )
    if hash_to_ct[ cthash ] and hash_to_ct[ cthash ] ~= ct then
      abort( "Collision! Hash:%d ct1:%s ct2:%s", hash, hash_to_id[ hash ], id )
    end
    hash_to_ct[ cthash ] = ct
    ct_to_hash[ ct     ] = cthash
    if self.task_ini:line_exist( sect_id, "target" ) then
      curr_task_info.target = self.task_ini:r_string( sect_id, "target" )
    end
    if self.task_ini:line_exist( id, "info" ) then
      curr_task_info.info = self.task_ini:r_string( sect_id, "info" )
    end
    if self.task_ini:line_exist( sect_id, "text" ) then
      curr_task_info.text = self.task_ini:r_string( sect_id, "text" )
    end
    if self.task_ini:line_exist( sect_id, "description" ) then
      curr_task_info.description = self.task_ini:r_string(
        sect_id, "description"
      )
    end
    curr_task_info.time      = utils.cfg_get_number(
      self.task_ini, sect_id, "time", nil, false
    )
    -- Время между выдачами задания (в игровых секундах)
    curr_task_info.idle_time = utils.cfg_get_number(
      self.task_ini, sect_id, "idle_time", nil, false, 24 * 60 * 60
    )
    -- Приоритет квеста, выдаются доступные квесты с наименьшим приоритетом
    curr_task_info.prior     = utils.cfg_get_number(
      self.task_ini, sect_id, "prior", nil, false, 0
    )
    if self.task_ini:line_exist( sect_id, "init_condition" ) then
      curr_task_info.init_condition = xr_logic.parse_condlist(
        db.actor, "task_manager", "init_condition",
        self.task_ini:r_string( sect_id, "init_condition" )
      )
    end
    local sss = utils.cfg_get_string(
      self.task_ini, sect_id, "reward_item", nil, false, ""
    )
    if sss ~= nil then
      curr_task_info.reward_item = se_respawn.parse_names( sss )
    else
      curr_task_info.reward_item = sss
    end
    curr_task_info.reward_money  = utils.cfg_get_number(
      self.task_ini, sect_id, "reward_money", nil, false
    )
    curr_task_info.reward_script = utils.cfg_get_string(
      self.task_ini, sect_id, "reward_script", nil, false, ""
    )
    -- Награда информацией
    local reward_info            = utils.cfg_get_string(
      self.task_ini, sect_id, "reward_info", nil, false, ""
    )
    if reward_info == "" then reward_info = nil end
    curr_task_info.reward_info = reward_info
    if reward_info then
      self:read_info_reward_section(
        self.task_ini, reward_info, curr_task_info
      )
    end
    -- Диалог для квестовой жертвы
    curr_task_info.target_dialog = utils.cfg_get_string(
      self.task_ini, sect_id, "target_dialog", nil, false, ""
    )
    if self.task_ini:line_exist( sect_id, "community" ) then
      curr_task_info.community = self.task_ini:r_string( sect_id, "community" )
    end
    curr_task_info.reward_rank = utils.cfg_get_number(
      self.task_ini, sect_id, "reward_rank", nil, false, 0
    )
    curr_task_info.reward_reputation = utils.cfg_get_number(
      self.task_ini, sect_id, "reward_reputation", nil, false
    )
    curr_task_info.reward_relation   = parse_key_value(
      utils.cfg_get_string(
        self.task_ini, sect_id, "reward_relation", nil, false, ""
      )
    )
    if self.task_ini:line_exist( sect_id, "condlist" ) then
      curr_task_info.condlist = xr_logic.parse_condlist(
        db.actor, "task_manager", "condlist",
        self.task_ini:r_string( sect_id, "condlist" )
      )
    else
      curr_task_info.condlist = xr_logic.parse_condlist(
        db.actor, "task_manager", "condlist", "true"
      )
    end
    curr_task_info.need_return = utils.cfg_get_bool(
      self.task_ini, sect_id, "need_return", nil, false, true
    )

    curr_task_info.init_phrase_id      = self:gen_phrase_id()
    curr_task_info.desc_phrase_id      = self:gen_phrase_id()
    curr_task_info.yes_phrase_id       = self:gen_phrase_id()
    curr_task_info.no_phrase_id        = self:gen_phrase_id()
    curr_task_info.completed_phrase_id = self:gen_phrase_id()

    -- По умолчанию квест доступен для выдачи
    curr_task_info.enabled       = true
    -- Доступен ли квест по своим свойствам. По умолчанию всегда
    -- недоступен. Этот параметр зависит от наличия целей для квестов
    -- и того срабатывает ли прекондишн квеста
    curr_task_info.enabled_props = false
    -- Статус квеста, может быть: "normal", "selected", "completed",
    -- "refused", "failed", "rewarded"
    curr_task_info.status        = "normal"
  end

  -- Создание дополнительных ассоциативных таблиц для облегчения поиска
  self.task_id_by_type                = {}
  self.task_id_by_complex_type        = {}
  self.task_id_by_parent              = {}
  self.task_id_by_yes_phrase_id       = {}
  self.task_id_by_completed_phrase_id = {}
  self.task_id_by_desc_phrase_id      = {}
  self.task_id_by_init_phrase_id      = {}
  self.active_task_by_type            = {}
  self.task_id_self_inited            = {}
  for k, v in pairs( self.task_info ) do
    -- По типу квеста
    if self.task_id_by_type[ v.type ] == nil then
      self.task_id_by_type[ v.type ] = {}
    end
    table.insert( self.task_id_by_type[ v.type ], k )
    -- По типу вендора
    if self.task_id_by_parent[ v.parent ] == nil then
      self.task_id_by_parent[ v.parent ] = {}
    end
    table.insert( self.task_id_by_parent[ v.parent ], k )
    -- По id фразы согласия на квест
    self.task_id_by_yes_phrase_id[ v.yes_phrase_id ] = k
    self.task_id_by_completed_phrase_id[ v.completed_phrase_id ] = k
    self.task_id_by_desc_phrase_id[ v.desc_phrase_id ] = k
    -- По id фразы выдачи квеста.
    self.task_id_by_init_phrase_id[ v.init_phrase_id ] = k
    -- По самовыдаваемости
    if v.init_condition ~= nil then
      table.insert( self.task_id_self_inited, k )
      if not self.subscribed then
        self.subscribed = {
          signal = "on_update", self = self, fun = this.actor_update,
          script_name = "task_manager.actor_update",
        }
        ogse_signals.get_mgr():subscribe( self.subscribed )
      end
    end
    if not self.task_id_by_complex_type[ v.complex_type ] then
      self.task_id_by_complex_type[ v.complex_type ] = {}
    end
    table.insert( self.task_id_by_complex_type[ v.complex_type ], k )
  end
end


--------- Награда информацией --------
function CRandomTask:read_info_reward_section( ini, sect, container )
  local real_sect = "task_manager." .. sect
  local rip = utils.cfg_get_string(
    ini, real_sect, "info_portion", nil, true, ""
  )
  if rip ~= nil then
    container.reward_info_portion = se_respawn.parse_names( rip )
  else
    container.reward_info_portion = rip
  end
  container.reward_info_dialog = {}
  local phr = 1
  while true do
    local phrase_id = utils.cfg_get_string(
      ini, real_sect, "phrase_" .. phr, nil, false, ""
    )
    phr = phr + 1
    if phrase_id == nil or phrase_id == "" then break end
    table.insert( container.reward_info_dialog, phrase_id )
  end
end
--------------------------------------


-- Статус квеста, может быть: "normal", "selected", "completed",
-- "refused", "failed", "rewarded". Ну и замечательно. Запишем его
-- числом. - семикратная экономия.
local status_to_num = {
  normal    = 0,
  selected  = 1,
  completed = 2,
  refused   = 3,
  failed    = 4,
  rewarded  = 5,
}

local num_to_status = {
  [ 0 ] = "normal",
  [ 1 ] = "selected",
  [ 2 ] = "completed",
  [ 3 ] = "refused",
  [ 4 ] = "failed",
  [ 5 ] = "rewarded",
}


function CRandomTask:save()
  local tasks = {}
  for k, v in pairs( self.task_info ) do
    ASSERT( id_to_hash[ k ], "Cannot find hash for id %s!", k )
    ASSERT(
      status_to_num[ v.status ],
      "Wrong status '%s' for task %s!", v.status, k
    )
    table.insert(
      tasks,
      {
        id_to_hash[ k ],
        v.enabled,
        v.enabled_props,
        status_to_num[ v.status ],
        ( v.selected_target or 4294967295   ),
        ( v.defend_target   or 4294967295   ),
        ( v.last_task_time  or game.CTime() ),
      }
    )
  end
  ogse.save_var(
    "task_manager.tasks", tasks, "array_template",
    { "u16", "bool", "bool", "u8", "u32", "u32", "time" }
  )

  -- Та же самая процедура с активными тасками
  local active = {}
  for k, v in pairs( self.active_task_by_type ) do
    ASSERT( ct_to_hash[ k ], "Cannot find hash for complex type %s!", k )
    ASSERT( id_to_hash[ v ], "Cannot find hash for task id %s!", v )
    table.insert(
      active,
      {
        ct_to_hash[ k ],
        id_to_hash[ v ],
      }
    )
  end
  ogse.save_var(
    "task_manager.active", active, "array_template",
    { "u16", "u16" }
  )
  log2(
    "[%s]: %s tasks saved: %s active",
    script_name(), table.getn( tasks ), table.getn( active )
  )
end


-- Загрузка
function CRandomTask:load( p )
  local tasks = ogse.load_var_safe( "task_manager.tasks" )
  if not tasks then return self:load_old( p ) end
  for _, t in ipairs( tasks ) do
    local hash, enabled, enabled_props, status, selected_target, defend_target, last_task_time = unpack( t )
    local id   = hash_to_id[ hash ]
    ASSERT( id, "Cannot find id for hash %d!", hash )
    local info = self.task_info[ id ]
    info.enabled       = enabled
    info.enabled_props = enabled_props
    info.status        = num_to_status[ status ]
    if selected_target ~= 4294967295 then
      info.selected_target = selected_target
    end
    if defend_target ~= 4294967295 then
      info.defend_target = defend_target
    end
    info.last_task_time = last_task_time
  end
  -- Та же самая процедура с активными тасками
  local active = ogse.load_var_safe( "task_manager.active" )
  for _, t in ipairs( active ) do
    local cthash, hash = unpack( t )
    local id     = hash_to_ct[ cthash ]
    ASSERT( id, "Cannot find complex type for hash %d", cthash )
    self.active_task_by_type[ id ] = hash_to_id[ hash ]
    ASSERT(
      self.active_task_by_type[ id ], "Cannot find task id for hash %d!", hash
    )
  end
  log2(
    "[%s]: %s tasks loaded: %s active",
    script_name(), table.getn( tasks ), table.getn( active )
  )
end


local dsh_save_var_name = "task_manager.task_info"
function CRandomTask:load_old( p )
  if ogse.var_exists( dsh_save_var_name ) then
    p = ogse.load_var( dsh_save_var_name )
  end
  -- Считаем количество записей
  local i = p:r_u8()
  i = p:r_u8()
  local task_cnt = i
  for k = 1, i do
    local hash = p:r_u16()
    local id   = hash_to_id[ hash ]
    ASSERT( id, "Cannot find id for hash %d!", hash )
    local info = self.task_info[ id ]
    info.enabled       = p:r_bool()
    info.enabled_props = p:r_bool()
    info.status        = num_to_status[ p:r_u8() ]
    local selected_target = p:r_u32()
    if selected_target ~= 4294967295 then
      info.selected_target = selected_target
    end
    local defend_target = p:r_u32()
    if defend_target ~= 4294967295 then
      info.defend_target = defend_target
    end
    info.last_task_time = utils.r_CTime( p )
  end
  -- Та же самая процедура с активными тасками
  i = p:r_u8()
  local active_cnt = i
  for k = 1, i do
    local cthash = p:r_u16()
    local id     = hash_to_ct[ cthash ]
    ASSERT( id, "Cannot find complex type for hash %d", cthash )
    local hash   = p:r_u16()
    self.active_task_by_type[ id ] = hash_to_id[ hash ]
    ASSERT(
      self.active_task_by_type[ id ], "Cannot find task id for hash %d!", hash
    )
  end
  log2(
    "[%s]: %s tasks loaded: %s active", script_name(), task_cnt, active_cnt
  )
end


-- Генератор уникальных ID для фраз
function CRandomTask:gen_phrase_id()
  self.task_phrase_id = self.task_phrase_id + 1
  return tostring( self.task_phrase_id )
end


-- Возвращает идентификатор вендора, с которым мы говорим
function CRandomTask:get_parent( npc )
  local story_id = npc:story_id()
  if parent_by_story[ story_id ] == nil then
    abort( "Task manager error: wrong parent story_id[%s]", story_id )
  end
  return parent_by_story[ story_id ]
end


-- Может ли вендор выдать квест
function CRandomTask:parent_can_task( actor, npc, p1, p2, p3 )
  local parent = self:get_parent( npc )
  local avail  = false
  self:task_avail( actor, npc, nil, nil, nil, "reset" )
  for k, v in pairs( self.task_id_by_parent[ parent ] ) do
    if
      self:task_avail(
        actor, npc, nil, nil, self.task_info[ v ].init_phrase_id, true
      )
    then
      avail = true
    end
  end
  return avail
end


-- Есть ли у игрока хоть одно задание от данного вендора
function CRandomTask:active_parent_task( actor, npc )
  local parent = self:get_parent( npc )
  for k, v in pairs( self.active_task_by_type ) do
    local t = self.task_info[ v ]
    if
      t.parent == parent
      and ( t.status == "selected" or t.status == "completed" )
    then
      return true
    end
  end
  return false
end


-- Есть ли игрока завершенные задания ( которые осталось только сдать )
function CRandomTask:have_completed_job( actor, npc )
  local parent = self:get_parent( npc )
  for k, v in pairs( self.active_task_by_type ) do
    local t = self.task_info[ v ]
    if t.parent == parent and t.status == "completed" then
      return true
    end
  end
  return false
end


-- Выдача квеста игроку
function CRandomTask:action_give_task( actor, npc, p1, p2 )
  local task_id = self.task_id_by_yes_phrase_id[ p2 ]
  local t = self.task_info[ task_id ]
  -- Выбираем текущую цель квеста
  if t.target_objects then
    local n = table.getn( t.target_objects )
    t.selected_target = t.target_objects[ math.random( n ) ]
  end
  if t.type == "defend_lager" then
    local defend_object = alife():object( t.selected_target )
    local sm_ini        = defend_object:spawn_ini()
    t.defend_target = utils.cfg_get_number(
      sm_ini, "random_task", "defend_target", nil, true
    )
  elseif t.type == "kill_stalker" then
    -- Добавим id сталкера в список целей
    if t.target_dialog then
      amk_add_target_id_to_kill_targets(
        t.selected_target, t.target_dialog, task_id
      )
    end
  end
  if map_locations[ t.type ] and t.selected_target then
    level.map_add_object_spot_ser(
      t.selected_target, map_locations[ t.type ], t.text
    )
  end
  -- дизаблим все остальные задания данного типа, так как игрок не
  -- может одновременно обладать двумя заданиями одного типа.
  t.status = "selected"
  self.active_task_by_type[ t.complex_type ] = task_id
  local by_complex_type = self.task_id_by_complex_type[ t.complex_type ]
  for _, k in ipairs( by_complex_type ) do
    self.task_info[ k ].enabled = false
  end
  if t.time then
    local time = t.time > 365 and t.time or t.time * 86400
    ogse_st_mgr.start_gtimer(
      "task_manager.expire." .. t.name, time,
      "task_manager.expire_task", t.name
    )
  end
  t.timer = task_state_timer( t )
  t.timer:start()
end


-- Выдача движкового задания
function CRandomTask:action_give_task_engine( actor, npc, p1, p2 )
  local task      = CGameTask()
  local task_id   = self.task_id_by_yes_phrase_id[ p2 ]
  local task_desc = self.task_info[ task_id ]
  task:load( task_desc.complex_type )
  task:set_title( game.translate_string( task_desc.type ) )
  local oo = task:get_objective( 0 )
  oo:set_article_id( task_desc.description )
  local objective = SGameTaskObjective( task, 1 )
  objective:set_description( task_desc.name )
  -- Выбираем текущую цель квеста
  if task_desc.target_objects ~= nil then
    task_desc.selected_target = task_desc.target_objects[
      math.random( table.getn( task_desc.target_objects ) )
    ]
  end
  if task_desc.type == "eliminate_lager" then
    objective:set_map_hint( task_desc.text )
    objective:set_map_location( map_locations[ task_desc.type ] )
    objective:set_object_id( task_desc.selected_target )
  elseif task_desc.type == "defend_lager" then
    objective:set_map_hint( task_desc.text )
    objective:set_map_location( map_locations[ task_desc.type ] )
    objective:set_object_id( task_desc.selected_target )
    local defend_object = alife():object( task_desc.selected_target )
    local sm_ini = defend_object:spawn_ini()
    task_desc.defend_target = utils.cfg_get_number(
      sm_ini, "random_task", "defend_target", nil, true
    )
  elseif task_desc.type == "kill_stalker" then
    objective:set_map_hint( task_desc.text )
    objective:set_map_location( map_locations[ task_desc.type ] )
    objective:set_object_id( task_desc.selected_target )
    -- Добавим id сталкера в список целей
    if task_desc.target_dialog then
      amk_add_target_id_to_kill_targets(
        task_desc.selected_target, task_desc.target_dialog, task_id
      )
    end
  elseif task_desc.type == "find_item" then
    objective:set_map_hint( task_desc.text )
    objective:set_map_location( map_locations[ task_desc.type ] )
    objective:set_object_id( task_desc.selected_target )
  end
  objective:add_complete_func( "task_manager.task_complete" )
  task:add_objective (objective )

  if task_desc.need_return then
    objective = SGameTaskObjective( task, 2 )
    objective:set_description( return_task_by_type[ task_desc.type ] )
    objective:set_map_hint( return_task_by_type[ task_desc.type ] )
    objective:set_map_location( "blue_location" )
    local sobj = alife():story_object( story_by_parent[ task_desc.parent ] )
    if not sobj then
      -- Квестодателя прибили.
      return
    end
    objective:set_object_id( sobj.id )
    task:add_objective( objective )
  end

  local time = 0
  if task_desc.time ~= nil then
    local title_time = game.CTime()
    title_time:setHMS( 0, 0, task_desc.time )
    title_time:add( game.get_game_time() )
    task:set_title(
      task:get_title() .. "\\n%c[255,150,150,180]до "
        .. title_time:dateToString( game.CTime.DateToDay )
    )
    time = task_desc.time * 1000
  end
  db.actor:give_task( task, time, false )

  -- дизаблим все остальные задания данного типа, так как игрок не
  -- может одновременно обладать двумя заданиями одного типа.
  task_desc.status = "selected"
  self.active_task_by_type[ task_desc.complex_type ] = task_id
  local by_complex_type = self.task_id_by_complex_type[ task_desc.complex_type ]
  for _, k in ipairs( by_complex_type ) do
    self.task_info[ k ].enabled = false
  end
end


-- Отказ игроком от квеста
function CRandomTask:action_refuse_task( actor, npc, p1, p2 )
  local task_id = self.task_id_by_yes_phrase_id[ p2 ]
  local t = self.task_info[ task_id ]
  -- Делаем доступными все задания данного типа
  t.status = "refused"
  t.timer.notify = false
  t.timer:condition()
  t.timer:action()
  t.timer:stop()
  -- Удаляем цель из списка
  local by_type = self.active_task_by_type[ t.complex_type ]
  amk_remove_target_id_from_kill_targets(
    self.task_info[ by_type ].selected_target
  )
  self.task_info[ by_type ].selected_target = nil
  local by_complex_type = self.task_id_by_complex_type[ t.complex_type ]
  for _, k in ipairs( by_complex_type ) do
    self.task_info[ k ].enabled = true
  end
  if t.reward_reputation ~= nil then
    db.actor:change_character_reputation( -t.reward_reputation )
  end
  if t.reward_relation ~= nil then
    for kk, vv in pairs( t.reward_relation ) do
      relation_registry.change_community_goodwill(
        kk, db.actor:id(), -( tonumber( vv ) )
      )
    end
  end
  if t.reward_rank ~= nil then
    xr_statistic.add_actor_rank( -t.reward_rank * 5 )
  end
end


-- Проверяем, не выполнен ли таск
function CRandomTask:task_complete( p1, p2 )
  local t = self.task_info[ self.active_task_by_type[ p1 ] ]
  if not t then
    log1( "!!!" )
    print_table_inlog( self.active_task_by_type )
    log1( "!!!" )
    print_table_inlog(self.task_info)
    return false
  end

  if p2 == 0 then
    if ( not t.need_return ) and t.status == "completed" then
      t.last_task_time = game.get_game_time()
      return true
    end
    if t.status == "rewarded" then
      t.last_task_time = game.get_game_time()
      return true
    end
  end

  if p2 == 1 then
    if t.type == "eliminate_lager" then
      local oo = alife():object( t.selected_target )
      if oo and oo.gulag:get_population_comed() == 0 then
        t.status = "completed"
        if t.info then
          db.actor:give_info_portion( t.info )
        end
        return true
      end
    elseif t.type == "defend_lager" then
      if xr_gulag.getGulagPopulationComed( t.defend_target ) == 0 then
        t.status = "completed"
        return true
      end
    elseif t.type == "kill_stalker" then
      local oo = alife():object( t.selected_target )
      -- Проверка бага
      if oo == nil then
        log2( "selected_target = %s", tostring( t.selected_target ) )
        abort(
          "OBJ = nil for task %s", tostring( self.active_task_by_type[ p1 ] )
        )
      elseif oo.alive == nil then
        log2(
          "OBJ.ALIVE = nil for task %s",
          tostring( self.active_task_by_type[ p1 ] )
        )
        abort( "OBJ.NAME = %s", obj:name() )
      end
      if oo and oo:alive() == false then
        -- Сталкер убит. Удаляем его ид из списка  целей
        amk_remove_target_id_from_kill_targets( t.selected_target )
        t.status = "completed"
        return true
      end
    elseif
      t.type == "artefact" or t.type == "find_item" or t.type == "monster_part"
    then
      if amk_utils.inventory_search( t.target, 1 ) then
        t.status = "completed"
        return true
      end
    end
  end

  return false
end


-- Проверяем, не профейлен ли таск
function CRandomTask:task_fail( p1, p2 )
  if p2 == 0 then
    local t = self.task_info[ self.active_task_by_type[ p1 ] ]
    if not t then
      printf( "!!!" )
      print_table( self.active_task_by_type )
      printf( "!!!" )
      print_table( self.task_info )
      return false
    end

    -- Проверяем что жив, выдавший квест.
    local parent = alife():story_object( story_by_parent[ t.parent ] )
    if parent == nil or ( parent.alive ~= nil and not parent:alive() ) then
      t.status = "failed"
      t.last_task_time = game.get_game_time()
      return true
    end

    if t.status == "refused" or t.status == "failed" then
      t.last_task_time = game.get_game_time()
      return true
    end
    if t.type == "defend_lager" then
      if alife():object( t.selected_target ).gulag:get_population_comed() == 0 then
        t.status = "failed"
        t.last_task_time = game.get_game_time()
        return true
      end
    end
  end
  return false
end


-- Обнуление переменных при завершении или провале таска
function CRandomTask:task_callback( p1, p2, state )
  if p2 ~= 0 then return end
  if self.active_task_by_type[ p1 ] == nil then return end

  -- Удаляем цель из списка
  local task_info = self.task_info[ self.active_task_by_type[ p1 ] ]
  if task_info and task_info.selected_target then
    amk_remove_target_id_from_kill_targets( task_info.selected_target )
  end
  ----------------------------------

  if state == task.completed or state == task.fail then
    task_info.status = "normal"
    -- восстановление других заданий данного типа
    local by_complex_type = self.task_id_by_complex_type[ task_info.complex_type ]
    for _, k in ipairs( by_complex_type ) do
      self.task_info[ k ].enabled = true
    end
    self.active_task_by_type[ p1 ] = nil
  end
end


-- Выводит список доступных квестов
function CRandomTask:action_task_show( npc, actor )
  local parent = self:get_parent( npc )
  for k, v in pairs( self.task_id_by_parent[ parent ] ) do
    if
      self:task_avail(
        actor, npc, nil, nil, self.task_info[ v ].init_phrase_id, false
      )
    then
      local task_texture, task_rect = get_texture_info(
        "ui_iconsTotal_" .. self.task_info[ v ].type, "ui_iconsTotal_stalker10"
      )
      db.actor:give_talk_message(
        game.translate_string( self.task_info[ v ].name ),
        task_texture, task_rect, "iconed_trade_info"
      )
    end
  end
end


-- Проверка доступен ли текущий таск для выдачи
function CRandomTask:task_avail( actor, npc, p1, p2, p3, calculate )
  local id        = self.task_id_by_init_phrase_id[ p3 ]
  local task_desc = self.task_info[ id ]
  -- Если calculate == true то нужно проверять check_task_props, иначе
  -- просто вернуть значения.
  if calculate == "reset" then
    self.current_parent_type_prior = {}
    return
  elseif calculate == true then
    self:check_task_props( id )
    local enabled = task_desc.enabled and task_desc.enabled_props
      and task_desc.init_condition == nil
    -- Устанавливать обрезания по приоритетам тут.
    local priors  = self.current_parent_type_prior
    if
      enabled
      and (
        priors[ task_desc.complex_type ] == nil
        or priors[ task_desc.complex_type ] > task_desc.prior
      )
    then
      priors[ task_desc.complex_type ] = task_desc.prior
    end
    return enabled
  end

  -- local priors = self.current_parent_type_prior
  -- if
  --   priors[ task_desc.complex_type ]
  --   and priors[ task_desc.complex_type ] < task_desc.prior
  -- then
  --   return false
  -- end

  return task_desc.enabled and task_desc.enabled_props
    and task_desc.init_condition == nil
end


-- Проверка свойств таска
function CRandomTask:check_task_props( task_id )
  local t = self.task_info[ task_id ]
  -- Проверка по активным заданиям данного типа у вендора.
  if self.active_task_by_type[ t.complex_type ] ~= nil then
    t.enabled_props = false
    return
  end

  -- Проверка по кондлисту
  if
    xr_logic.pick_section_from_condlist(
      db.actor, db.actor, t.condlist
    ) == nil
  then
    t.enabled_props = false
    return
  end

  -- Проверка по таймауту
  if
    t.last_task_time ~= nil
    and
    game.get_game_time():diffSec( t.last_task_time ) < t.idle_time
  then
    t.enabled_props = false
    return
  end

  -- проверка по таргету
  if t.type == "eliminate_lager" then
    if t.target_objects == nil then
      t.enabled_props = false
      return
    end
    for k, v in pairs( t.target_objects ) do
      local gulag = alife():object( v ).gulag
      if gulag:get_population_comed() > 0 then
        t.enabled_props = true
        return
      end
    end
    t.enabled_props = false
    return
  elseif t.type == "defend_lager" then
    if t.target_objects == nil then
      t.enabled_props = false
      return
    end
    for k, v in pairs( t.target_objects ) do
      local defend_object = alife():object( v )
      local sm_ini        = defend_object:spawn_ini()
      local defend_target = utils.cfg_get_number(
        sm_ini, "random_task", "defend_target", nil, true
      )
      if
        xr_gulag.getGulagPopulationComed( defend_target ) >= xr_gulag.getGulagCapacity( defend_target )
      then
        t.enabled_props = true
        return
      end
    end
    t.enabled_props = false
    return
  elseif t.type == "kill_stalker" then
    t.enabled_props = false
    return
  elseif t.type == "find_item" then
    if t.target_objects == nil or table.getn( t.target_objects ) == 0 then
      t.enabled_props = false
      return
    end
    for k, v in pairs( t.target_objects ) do
      local obj = alife():object( v )
      if obj ~= nil then
        -- Нужно игнорировать предметы, которые находяться у вендоров.
        if obj.parent_id ~= nil then
          for kk, vv in pairs( parent_by_story ) do
            local parent = alife():story_object( kk )
            if parent ~= nil and obj.parent_id == parent.id then
              -- Игнорим предмет
              t.enabled_props = false
              return
            end
          end
        end
        t.enabled_props = true
        return
      end
      t.enabled_props = false
      return
    end
  else
    t.enabled_props = true
    return
  end
end


-- Проверяем можем ли мы сейчас выдать какой либо самоинициализующийся таск
function CRandomTask:actor_update()
  ogse_signals.get_mgr():reschedule( 1000 )
  for k, v in pairs( self.task_id_self_inited ) do
    local t = self.task_info[ v ]
    if t.status == "normal" then
      self:check_task_props( v )
      if
        t.enabled_props == true and t.enabled == true
        and xr_logic.pick_section_from_condlist(
          db.actor, db.actor, t.init_condition
        ) ~= nil
      then
        -- Нужно автоматически выдать квест
        self:action_give_task( db.actor, nil, nil, t.yes_phrase_id )
      end
    end
  end
end


-- Функция для аварийной зачистки - убирает у неактивных квестов дату
-- последнего обращения, список объектов и текущий объект, в
-- результате чего позволяет освободить довольно приличное количество
-- места в хранилище ГГ
function CRandomTask:cleanup_actor()
  for k, v in pairs( self.task_info ) do
    if v.status == "normal" then
      if
        v.type == "eliminate_lager"
        or v.type == "defend_lager"
        or v.type == "kill_stalker"
        or v.type == "artefact"
        or v.type == "find_item"
        or v.type == "monster_part"
        or v.type == "storyline"
      then
        v.last_task_time  = nil
        v.selected_target = nil
        v.target_objects  = nil
      end
    end
  end
end


-- Проверяется является ли текущий таск выданным игроку
function CRandomTask:active_task( actor, npc, p1, p2, p3 )
  local t = self.task_info[ self.task_id_by_init_phrase_id[ p3 ] ]
  return t.status == "selected" or t.status == "completed"
end


function CRandomTask:is_task_active( id )
  return self.task_info[ id ].status == "selected"
end


function CRandomTask:make_task_failed( task_id )
  local t = self.task_info[ task_id ]
  if not t then return end
  t.status = "failed"
  if t.type == "defend_lager" or t.type == "eliminate_lager" then
    if t.reward_reputation ~= nil then
      db.actor:change_character_reputation( -t.reward_reputation * 20 )
    end
    if t.reward_relation ~= nil then
      for kk, vv in pairs( t.reward_relation ) do
        relation_registry.change_community_goodwill(
          kk, db.actor:id(), -( tonumber( vv ) ) * 20
        )
      end
    end
    if t.reward_rank ~= nil then
      xr_statistic.add_actor_rank( -t.reward_rank * 20 )
    end
  end
end


-- Проверяется наличие квестовых предметов
function CRandomTask:completed_task( actor, npc, p1, p2, p3 )
  if not p3 then return false end
  local tid = self.task_id_by_desc_phrase_id[ p2 ]
  if not tid then return false end
  local task_desc = self.task_info[ tid ]
  if task_desc.status ~= "completed" then return false end
  local can_finish = true
  if task_desc.type == "artefact" then
    if not amk_utils.inventory_search( task_desc.target, 1 ) then
      can_finish = false
    end
  elseif task_desc.type == "monster_part" then
    if not amk_utils.inventory_search( task_desc.target, 1 ) then
      can_finish = false
    end
  elseif task_desc.type == "find_item" then
    if not amk_utils.inventory_search( task_desc.target, 1 ) then
      can_finish = false
    end
  end
  return can_finish
end


-- Создается диалог актера, в котором будут выдаваться задания.
function CRandomTask:init_task_dialog( dlg, parent )
  local phr = dlg:AddPhrase( "tm_seek_new_job", "0", "", -10000 )
  local phrase_script = phr:GetPhraseScript()
  phr = dlg:AddPhrase( "tm_" .. parent .. "_list_job", "1", "0", -10000 )
  phrase_script = phr:GetPhraseScript()
  phrase_script:AddAction( "task_manager.action_task_show" )
  phrase_script:AddPrecondition( "task_manager.precondition_vendor_can_task" )
  phr = dlg:AddPhrase( "tm_" .. parent .. "_has_no_job", "2", "0", -10000 )
  phrase_script = phr:GetPhraseScript()
  phrase_script:AddPrecondition( "task_manager.precondition_vendor_cannot_task" )
  for k, v in pairs( self.task_id_by_parent[ parent ] ) do
    local t = self.task_info[ v ]
    phr = dlg:AddPhrase( t.name, tostring( t.init_phrase_id ), "1", -10000 )
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddPrecondition( "task_manager.precondition_task_avail" )
    phr = dlg:AddPhrase(
      t.text, tostring( t.desc_phrase_id ), tostring( t.init_phrase_id ), -10000
    )
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction( "task_manager.show_reward" )
    phr = dlg:AddPhrase(
      "tm_seek_job_yes", tostring( t.yes_phrase_id ),
      tostring( t.desc_phrase_id ), -10000
    )
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction( "task_manager.action_give_task" )
    phr = dlg:AddPhrase(
      "tm_seek_job_no", tostring( t.no_phrase_id ),
      tostring( t.desc_phrase_id ), -10000
    )
  end
  dlg:AddPhrase( "tm_seek_job_abandon", "3", "1", -10000 )
end


-- Функция, в которой будет выдаваться вещевая награда за выполненные
-- квесты
function CRandomTask:task_reward( npc, actor, p1, p2 )
  local parent = self:get_parent( npc )
  local v = self.task_id_by_completed_phrase_id[ p2 ]
  local t = self.task_info[ v ]
  if t.status == "completed" and t.parent == parent then
    -- Забираем у игрока квестовый предмет.
    local can_finish = true
    if t.type == "artefact" then
      if not amk_utils.inventory_search( t.target, 1 ) then
        can_finish = false
      else
        amk_utils.out_items_number({
          [ t.target ] = 1,
        })
      end
    elseif t.type == "monster_part" then
      if not amk_utils.inventory_search( t.target, 1 ) then
        can_finish = false
      else
        amk_utils.out_items_number({
          [ t.target ] = 1,
        })
      end
    elseif t.type == "find_item" then
      if not amk_utils.inventory_search( t.target, 1 ) then
        can_finish = false
      else
        amk_utils.out_items_number({
          [ t.target ] = 1,
        })
      end
    end
    if can_finish == true then
      t.status = "rewarded"
      if t.reward_money ~= nil then
        dialogs.relocate_money( npc, t.reward_money, "in" )
      end
      if t.reward_item ~= nil then
        for kk, vv in pairs( t.reward_item ) do
          if dsh.is_artefact( vv ) then
            local prop = amk_utils.get_item_props( vv )
            if prop.has_af_dyn then
              vv = amk_anoms.make_dyn_art_sect( vv )
            end
          end
          local items = dialogs.relocate_item_section( npc, vv, "in" )
        end
      end
      if t.reward_reputation ~= nil then
        db.actor:change_character_reputation( t.reward_reputation )
      end
      if t.reward_relation ~= nil then
        for kk, vv in pairs( t.reward_relation ) do
          relation_registry.change_community_goodwill(
            kk, db.actor:id(), tonumber( vv )
          )
        end
      end
      if t.reward_rank ~= nil then
        xr_statistic.add_actor_rank( t.reward_rank )
      end
      if t.reward_script ~= nil then
        _G.task_manager[ t.reward_script ]()
      end
      if cycle_task[ t.type ] then
        local koef = 0
        if not has_alife_info( "stat_" .. t.name ) then
          koef = 1
          db.actor:give_info_portion( "stat_" .. t.name )
        end
        actor_stats.add_points( "quests", t.name, 1, koef )
        archievements.acv_count_3event(
          "acv_ct",   500, "Наёмник",
          "acv_ct2", 1000, "Стаханов",
          "acv_ct3", 2000, "Папа Карло"
        )
        self:task_callback( t.complex_type, 0, task.completed )
      end
    end
  end
end


-- Функция, в которой будет выдаваться вещевая награда за выполненные
-- сторилайновые квесты
function CRandomTask:task_reward_storyline( task )
  local task_desc = self.task_info[ task:get_id() ]
  if task_desc == nil or task_desc.type ~= "storyline" then
    return
  end
  if task_desc.reward_reputation ~= nil then
    db.actor:change_character_reputation( task_desc.reward_reputation )
  end
  if task_desc.reward_relation ~= nil then
    for kk, vv in pairs( task_desc.reward_relation ) do
      relation_registry.change_community_goodwill(
        kk, db.actor:id(), tonumber( vv )
      )
    end
  end
  if task_desc.reward_rank ~= nil then
    xr_statistic.add_actor_rank( task_desc.reward_rank )
  end
end


-- Создается диалог актера, в котором будут приниматься задания
function CRandomTask:init_reward_dialog( dlg, parent )
  local phr = dlg:AddPhrase( "tm_reward_job", "0", "", -10000 )
  local phrase_script = phr:GetPhraseScript()
  phr = dlg:AddPhrase( "tm_" .. parent .. "_job_ask", "2", "0", -10000 )
  phrase_script = phr:GetPhraseScript()

  -- Список возможных квестов трейдера.
  for k, v in pairs( self.task_id_by_parent[ parent ] ) do
    local t = self.task_info[ v ]
    phr = dlg:AddPhrase( t.name, tostring( t.init_phrase_id ), "2", -10000 )
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddPrecondition( "task_manager.precondition_active_task" )
    phr = dlg:AddPhrase(
      "tm_" .. parent .. "_job_what", tostring( t.desc_phrase_id ),
      tostring( t.init_phrase_id ), -10000
    )
    phr = dlg:AddPhrase(
      "tm_job_refuse", tostring( t.yes_phrase_id ),
      tostring( t.desc_phrase_id ), -10000
    )
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction( "task_manager.action_refuse_task" )
    phrase_script:AddPrecondition( "task_manager.precondition_notcompleted_task" )
    phr = dlg:AddPhrase(
      "tm_job_nothing", tostring( t.no_phrase_id ),
      tostring( t.desc_phrase_id ), -10000
    )
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddPrecondition(
      "task_manager.precondition_notcompleted_task"
    )
    phr = dlg:AddPhrase(
      "tm_job_completed", tostring( t.completed_phrase_id ),
      tostring( t.desc_phrase_id ), -10000
    )
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction( "task_manager.action_task_reward" )
    phrase_script:AddPrecondition( "task_manager.precondition_completed_task" )
    if t.reward_info then
      local phrcnt = table.getn( t.reward_info_dialog )
      if phrcnt == 0 then
        local has_new_info = false
        for _, infop in ipairs( t.reward_info_portion ) do
          if db.actor:dont_has_info( infop ) then
            phrase_script:AddGiveInfo( infop )
            has_new_info = true
          end
        end
        if has_new_info then
          phrase_script:AddAction( "amk_dialogs.info_received" )
        end
      else
        -- Добавляем фразу. на случай наличия инфопорции. Иначе вылетит.
        phr = dlg:AddPhrase(
          "...", self:gen_phrase_id(), tostring( t.completed_phrase_id ), -10000
        )
        phrase_script = phr:GetPhraseScript()
        for _, infop in ipairs( t.reward_info_portion ) do
          if db.actor:dont_has_info( infop ) then
            phrase_script:AddHasInfo( infop )
          end
        end
        local prid  = tostring( t.completed_phrase_id )
        local first = true
        -- Добавляем диалог
        for i, p in ipairs( t.reward_info_dialog ) do
          local cid = self:gen_phrase_id()
          phr  = dlg:AddPhrase( p, cid, prid, -10000 )
          prid = cid
          if first then
            first = false
            phrase_script = phr:GetPhraseScript()
            local has_new_info = false
            for _, infop in ipairs( t.reward_info_portion ) do
              phrase_script:AddGiveInfo( infop )
              phrase_script:AddDontHasInfo( infop )
              if db.actor:dont_has_info( infop ) then
                has_new_info = true
              end
            end
            if has_new_info then
              phrase_script:AddAction( "amk_dialogs.info_received" )
            end
          end
        end
      end
    end
  end
end


-- Регистрация целей для квестов.
function CRandomTask:register_target( obj )
  if IAmAStalker[ obj:clsid() ] then
    -- Возможно регистрируется цель для квеста "убить сталкера"
    for k, v in pairs(self.task_id_by_type.kill_stalker ) do
      local t = self.task_info[ v ]
      if
        obj.alive ~= nil and obj:alive() == true
        and obj:profile_name() == t.target
      then
        if t.target_objects == nil then
          t.target_objects = {}
        end
        table.insert( t.target_objects, obj.id )
      end
    end
  elseif obj:clsid() == clsid.smart_terrain then
    -- Возможно регистрируется цель для квеста "вынести лагерь"
    for k, v in pairs( self.task_id_by_type.eliminate_lager ) do
      local t = self.task_info[ v ]
      if obj:name() == t.target then
        if t.target_objects == nil then
          t.target_objects = {}
        end
        table.insert( t.target_objects, obj.id )
      end
    end
    -- Либо регистрируется цель для квеста "защитить лагерь"
    for k, v in pairs( self.task_id_by_type.defend_lager ) do
      local t = self.task_info[ v ]
      if obj:name() == t.target then
        -- Проверка что в кастом дате указано от кого защищать
        local sm_ini        = obj:spawn_ini()
        local defend_target = utils.cfg_get_number(
          sm_ini, "random_task", "defend_target", nil, true
        )
        if t.target_objects == nil then
          t.target_objects = {}
        end
        table.insert( t.target_objects, obj.id )
      end
    end
  else
    -- Возможно регистрируется цель для квеста "найти предмет"
    for k, v in pairs( self.task_id_by_type.find_item ) do
      local t = self.task_info[ v ]
      if obj:section_name() == t.target then
        if t.target_objects == nil then
          t.target_objects = {}
        end
        table.insert( t.target_objects, obj.id )
      end
    end
  end
end


-- ОТРегистрация целей для квестов.
function CRandomTask:unregister_target( obj )
  if IAmAStalker[ obj:clsid() ] then
    -- Возможно регистрируется цель для квеста "убить сталкера"
    for k, v in pairs( self.task_id_by_type.kill_stalker) do
      local t = self.task_info[ v ]
      if t.target_objects ~= nil then
        for kk, vv in pairs( t.target_objects ) do
          if vv == obj.id then
            table.remove( t.target_objects, vv )
            break
          end
        end
      end
    end
  elseif obj:clsid() == clsid.smart_terrain then
  else
    -- Возможно регистрируется цель для квеста "найти предмет"
    for k, v in pairs( self.task_id_by_type.find_item ) do
      local t = self.task_info[ v ]
      if t.target_objects ~= nil then
        for kk, vv in pairs( t.target_objects ) do
          if vv == obj.id then
            table.remove( t.target_objects, vv )
            break
          end
        end
      end
    end
  end
end


--' Напоминания
function CRandomTask:remind()
  local sms = {}
  for k, v in pairs( self.active_task_by_type ) do
    local task_desc = self.task_info[ v ]
    if task_desc.status == "completed" then
      local sid    = story_by_parent[ task_desc.parent ]
      local parent = alife():story_object( sid )
      if
        parent
        and ( parent:clsid() == clsid.script_trader or parent:alive() )
        and game_graph():vertex( parent.m_game_vertex_id ):level_id() == alife():level_id()
      then
        -- формируем сообщение
        if not sms[ sid ] then
          sms[ sid ] = { name = get_parent_name( parent, sid ), txt = "" }
        end
        local txt_desc
        if
          task_desc.type == "artefact"
          or task_desc.type == "monster_part"
          or task_desc.type == "find_item"
        then
          txt_desc = task_desc.name
        else
          txt_desc = return_task_by_type[ task_desc.type ]
        end
        sms[ sid ].txt = sms[ sid ].txt
          .. "%c[255,127,255,255]" .. game.translate_string( task_desc.type )
          .. ": %c[default]" .. game.translate_string( txt_desc ) .. "\\n"
      end
    elseif
      task_desc.status == "selected"
      and (
        task_desc.type == "defend_lager" or task_desc.type == "eliminate_lager"
      )
    then
      local sobj = alife():object( task_desc.selected_target )
      if object_level_name( sobj ) == level.name() then
        local sid    = story_by_parent[ task_desc.parent ]
        local parent = alife():story_object( sid )
        if not sms[ sid ] then
          sms[ sid ] = {
            name = get_parent_name( parent, sid ),
            txt  = ""
          }
        end
        sms[ sid ].txt = sms[ sid ].txt
          .. "%c[255,127,255,255]" .. game.translate_string( task_desc.type )
          .. ": %c[default]" .. game.translate_string( task_desc.name ) .. "\\n"
      end
    end
  end

  -- Выдаем напоминания
  for k, v in pairs( sms ) do
    reminder.send_info(
      "%c[255,0,255,255]" .. v.name .. "\\n%c[default]" .. v.txt
    )
  end
end


function CRandomTask:stats( obj )
  log1( "### TASK STATISTIC ###" )
  for k, v in pairs( self.task_info ) do
    if v.init_condition ~= nil then
      log2( "[%s] %s : %s", v.status, k, tostring( v.enabled_props ) )
      print_table( v.init_condition )
    end
  end
end


local random_task
function get_random_task()
  if not random_task then
    random_task = CRandomTask()
  end
  return random_task
end


function init_trader_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "trader" )
end

function init_barman_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "barman" )
end

function init_ecolog_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "ecolog" )
end

function init_dolg_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "dolg" )
end

function init_freedom_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "freedom" )
end

function init_shustriy_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "shustriy" )
end

function init_lisiy_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "lisiy" )
end

function init_hunter_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "hunter" )
end

function init_drunk_dolg_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "drunk_dolg" )
end

function init_petrenko_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "petrenko" )
end

function init_wolf_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "wolf" )
end

function init_zastava_commander_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "zastava_commander" )
end

function init_mercenary_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "mercenary" )
end

function init_green_task_dialog( dlg )
  get_random_task():init_task_dialog( dlg, "green" )
end


function init_trader_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "trader" )
end

function init_barman_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "barman" )
end

function init_ecolog_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "ecolog" )
end

function init_dolg_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "dolg" )
end

function init_freedom_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "freedom" )
end

function init_shustriy_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "shustriy")
end

function init_lisiy_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "lisiy" )
end

function init_hunter_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "hunter" )
end

function init_drunk_dolg_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "drunk_dolg" )
end

function init_petrenko_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "petrenko" )
end

function init_wolf_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "wolf" )
end

function init_zastava_commander_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "zastava_commander" )
end

function init_mercenary_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "mercenary" )
end

function init_green_reward_dialog( dlg )
  get_random_task():init_reward_dialog( dlg, "green" )
end


function has_active_vendor_task( actor, npc )
  return get_random_task():active_parent_task( actor, npc )
end


function precondition_task_avail( actor, npc, p1, p2, p3 )
  return get_random_task():task_avail( actor, npc, p1, p2, p3, false )
end


function precondition_active_task( actor, npc, p1, p2, p3 )
  return get_random_task():active_task( actor, npc, p1, p2, p3 )
end


function precondition_completed_task( actor, npc, p1, p2, p3 )
  return get_random_task():completed_task( actor, npc, p1, p2, p3 )
end


function precondition_notcompleted_task( actor, npc, p1, p2, p3 )
  return not get_random_task():completed_task( actor, npc, p1, p2, p3 )
end


function precondition_vendor_can_task( npc, actor, p1, p2, p3 )
  return get_random_task():parent_can_task( actor, npc, p1, p2, p3 )
end


function precondition_vendor_cannot_task( npc, actor, p1, p2, p3 )
  return not get_random_task():parent_can_task( actor, npc, p1, p2, p3 )
end


function precondition_have_completed_job( npc, actor, p1, p2, p3 )
  return get_random_task():have_completed_job( actor, npc )
end


function precondition_dont_have_completed_job( npc, actor, p1, p2, p3 )
  return not get_random_task():have_completed_job( actor, npc )
end


function action_task_show( npc, actor )
  get_random_task():action_task_show( npc, actor )
end

function action_give_task( actor, npc, p1, p2 )
  get_random_task():action_give_task( actor, npc, p1, p2 )
end

function action_refuse_task( npc, actor, p1, p2 )
  get_random_task():action_refuse_task( npc, actor, p1, p2 )
end

function action_task_reward( actor, npc, p1, p2 )
  get_random_task():task_reward( npc, actor, p1, p2 )
end


function reward_by_task( task )
  get_random_task():task_reward_storyline( task )
end


function task_complete( p1, p2 )
  return get_random_task():task_complete( p1, p2 )
end

function task_fail( p1, p2 )
  return get_random_task():task_fail( p1, p2 )
end

function task_callback( p1, p2, state )
  return get_random_task():task_callback( p1, p2, state )
end


function actor_update()
  get_random_task():actor_update()
end


function cleanup_actor()
  get_random_task():cleanup_actor()
end


function save()
  get_random_task():save()
end


function load( p )
  get_random_task():load( p )
end


function clear_task_manager()
  random_task  = nil
end


function amk_add_target_id_to_kill_targets( id, dialog, task_id )
  local targets = amk_kill_targets()
  table.insert( targets, { id = id, dialog = dialog, task_id = task_id } )
  amk.save_variable( "kill_targets", amk.pack_array_to_string( targets ) )
end


function amk_remove_target_id_from_kill_targets( id )
  local targets = amk_kill_targets()
  for n, v in pairs( targets ) do
    if v.id == id then
      table.remove( targets, n )
      break
    end
  end
  amk.save_variable( "kill_targets", amk.pack_array_to_string( targets ) )
end


function amk_kill_targets()
  return amk.unpack_array_from_string(
    amk.load_variable( "kill_targets", "" )
  )
end


function make_task_failed( task_id )
  get_random_task():make_task_failed( task_id )
end


function show_reward( actor, npc, p1, p2 )
  local task_id      = random_task.task_id_by_desc_phrase_id[ p2 ]
  local task_details = get_random_task().task_info[ task_id ]
  if task_details == nil then return end
  local reward_text = format_reward_text( task_details.reward_item )
  if reward_text ~= nil and reward_text ~= "" then
    db.actor:give_talk_message(
      "Я тебе за это дам вот что:",
      "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item"
    )
    local task_texture, task_rect = get_texture_info(
      "ui_iconsTotal_find_item"
    )
    db.actor:give_talk_message(
      reward_text, task_texture, task_rect, "iconed_trade_info"
    )
  end
  local reward_money = task_details.reward_money
  if reward_money ~= nil then
    local task_texture, task_rect = get_texture_info(
      "ui_iconsTotal_found_money"
    )
    if task_details.need_return and reward_text == "" then
      db.actor:give_talk_message(
        reward_money
          .. " RU (" .. game.translate_string( "return_for_reward" ) .. ")",
        task_texture, task_rect, "iconed_trade_info"
      )
    else
      db.actor:give_talk_message(
        reward_money .. " RU", task_texture, task_rect, "iconed_trade_info"
      )
    end
  end
end


function format_reward_text( reward_list )
  if reward_list == nil then return "" end
  local rwd = {}
  for i, v in pairs( reward_list ) do
    if rwd[ v ] == nil then
      rwd[ v ] = 1
    else
      rwd[ v ] = rwd[ v ] + 1
    end
  end
  local reward_text = ""
  for i, v in pairs( rwd ) do
    if v == 1 then
      reward_text = reward_text
        .. game.translate_string( news_manager.get_inv_name( i ) ) .. ", "
    else
      reward_text = reward_text
        .. string.format( "%sx ", v )
        .. game.translate_string( news_manager.get_inv_name( i ) ) .. ", "
    end
  end
  if string.len( reward_text ) >= 2 then
    reward_text = string.sub( reward_text, 1, string.len( reward_text ) - 2 )
  end
  return reward_text
end


-- имя вендора
function get_parent_name( obj, sid )
  local trader_names = {
    [   3  ] = "Сидорович",
    [ 9511 ] = "Василий",
  }
  if obj:clsid() == clsid.script_trader then
    return trader_names[ sid ]
  else
    local pk = get_netpk( obj, 1 )
    ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", obj:name() )
    local data = pk:get()
    return data.character_name
  end
end


-- функции наград
function bad_day()
  if not ogse.load_var( "task_manager.bad_day", false ) then
    game.start_tutorial( "bad_day" )
    ogse.save_var( "task_manager.bad_day", true, "bool" )
  end
end


function is_task_active( id )
  return get_random_task():is_task_active( id )
end


class "task_state_timer" ( ogse_qt.quick_timer )
function task_state_timer:__init( t )
  self.hiprio      = true
  self.notify      = t.type == "defend_lager"
    or t.type == "eliminate_lager" or t.type == "kill_stalker"
  self.random_task = get_random_task()
  self.sm          = ogse_signals.get_mgr()
  self.script_name = "task_manager.task_state_timer." .. t.name
  self.task_info   = t
  if t.selected_target then
    local sobj = alife():object( t.selected_target )
    ASSERT(
      sobj,
      "[%s]: %s: selected_target %s not found",
      script_name(), t.name, t.selected_target
    )
    self.hiprio = object_level_name( sobj ) == level.name()
  end
end

function task_state_timer:condition()
  local ct = self.task_info.complex_type
  return self.random_task:task_fail( ct, 0 )
    or self.random_task:task_complete( ct, 1 )
end

function task_state_timer:action()
  local ct = self.task_info.complex_type
  if
    self.task_info.status == "completed"
    and not self.task_info.need_return
  then
    self.random_task:task_complete( ct, 0 )
    self.random_task:task_callback( ct, 0, task.completed )
  elseif self.task_info.status == "failed" then
    self.random_task:task_callback( ct, 0, task.fail      )
  end
  if map_locations[ self.task_info.type ] then
    level.map_remove_object_spot(
      self.task_info.selected_target, map_locations[ self.task_info.type ]
    )
  end
  if self.task_info.time then
    local tn = "task_manager.expire." .. self.task_info.name
    if ogse_st_mgr.timer_exists( tn ) then
      ogse_st_mgr.get_timer( tn ):stop()
    end
  end
  if not self.notify then return end
  pda_task:play( db.actor, 0, sound_object.s2d )
  local text_color
  if self.task_info.status == "failed" then
    text_color = "%c[255,255,0,0]"
      .. game.translate_string( "general_fail_task" ) .. "\\n"
  else
    text_color = "%c[255,160,160,160]"
      .. game.translate_string( "general_complete_task" ) .. "\\n"
  end
  local task_texture, task_rect = get_texture_info(
    "ui_iconsTotal_" .. self.task_info.type, "ui_iconsTotal_stalker10"
  )
  local news_text = text_color
    .. "%c[255,127,255,255]"
    .. game.translate_string( self.task_info.name )
  if db.actor:is_talking() then
    db.actor:give_talk_message(
      news_text, task_texture, task_rect, "iconed_answer_item"
    )
  end
  db.actor:give_game_news( news_text, task_texture, task_rect, 0, 5000 )
  local hud = get_hud()
  hud:AddCustomStatic( "main_task", true )
  hud:GetCustomStatic( "main_task" ):wnd():SetTextST( news_text )
  hud:GetCustomStatic( "main_task" ).m_endTime = time_global() / 1000 + 7
end

function task_state_timer:update()
  if self.hiprio then
    self.sm:reschedule( math.random( 1000,  2000 ) )
  else
    self.sm:reschedule( math.random( 5000, 10000 ) )
  end
end


function on_spawn()
  local cnt, launched_cnt = 0, 0
  local tasks = get_random_task()
  for k, v in pairs( tasks.active_task_by_type ) do
    local t = tasks.task_info[ v ]
    cnt = cnt + 1
    if
      not (
        t.status == "completed" or t.status == "failed"
        or db.actor:get_task_state( t.complex_type, 0 ) ~= task.task_dummy
      )
    then
      t.timer = task_state_timer( t )
      t.timer:start()
      launched_cnt = launched_cnt + 1
    end
  end
  log2(
    "[%s]: %s/%s active tasks launched", script_name(), launched_cnt, cnt
  )
end


function expire_task( task_id )
  get_random_task():make_task_failed( task_id )
end
